<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.125.5"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Mind in the Wind</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="ExampleSite description"><meta name=author content="Me"><link rel=canonical href=https://runzhen.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.103f87022495ee8537d399aa50bf7e2203f4c653b709467478c7fd5a58182364.css integrity="sha256-ED+HAiSV7oU305mqUL9+IgP0xlO3CUZ0eMf9WlgYI2Q=" rel="preload stylesheet" as=style><link rel=icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://runzhen.github.io/index.xml><link rel=alternate hreflang=en href=https://runzhen.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Mind in the Wind"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://runzhen.github.io/"><meta property="og:image" content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="Mind in the Wind"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Mind in the Wind"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Mind in the Wind","url":"https://runzhen.github.io/","description":"ExampleSite description","thumbnailUrl":"https://runzhen.github.io/%3Clink%20/%20abs%20url%3E","sameAs":["/index.xml","https://github.com/run"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://runzhen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://runzhen.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://runzhen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://runzhen.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://runzhen.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://runzhen.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>使用 nsenter 从 k8s Pod 逃逸到 Host</h2></header><div class=entry-content><p>本文是读完 Detecting a Container Escape with Cilium and eBPF 和 使用 Cilium 增强 Kubernetes 网络安全 的一个简单总结。
如何从 Pod 逃逸到 Host 通常为了安全起见，生产环境的 docker image 都要求不使用 root，一般都是在 Dockerfile 中指定 USER xxx，这样启动的 container/pod 是使用非特权的 user，这样的 user 是没法用 sudo 安装软件的。
有时为了能临时 debug，需要安装 vim, curl 之类的命令，又不想改动 Dockerfile 重新 build image，该怎么办呢？
一个 k8s 原生支持的方法是在 deployment 里面指定 securityContext，如下所示
$ cat privileged.yaml apiVersion: v1 kind: Pod metadata: name: privileged-the-pod spec: hostPID: true hostNetwork: true containers: - name: privileged-the-pod image: nginx:latest ports: - containerPort: 80 securityContext: privileged: true 对于 docker container，可以在指定 docker run 命令时，设置 --user 为 0 也能获得 root 的 container。...</p></div><footer class=entry-footer><span title='2022-04-03 00:00:00 +0000 UTC'>2022-04-03</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 使用 nsenter 从 k8s Pod 逃逸到 Host" href=https://runzhen.github.io/posts/nsenter-escape-from-pod-to-host/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Rust WASM 自制俄罗斯方块游戏</h2></header><div class=entry-content><p>起因 事情的起因是在 Switch 上玩 Tetris99 游戏，由于不喜欢这种吃鸡的形式，只想玩小时候的那种掌机模式，于是想到可不可以自己做一个。
有了这个想法以后，打算使用 Rust + WASM，一方面是学习一下新技术，另一方面考虑到能直接在浏览器运行，可以跨平台，甚至可以在电视机上用浏览器打开网页就可以玩。
选定技术栈以后，在 Github 上搜了一下，发现早有人做了类似的工作，不过没关系，主要还是要自己实现一下。
几种技术方案 学习了一圈以后，理解了用 Rust + WASM 实现一个 web 游戏的大体思路。
首先，Rust 的 wasm-bindgen 库必不可少，这是连接 rust 代码和 wasm 之间的桥梁。
其次，既然是 web 游戏，那么免不了要画图，如何画图呢？ 大家都不约而同的选择了 HTML 的 canvas，这是一种 html 标准自带的画图方式，比如用下面这样简单的代码，就能画一个矩形。
&lt;html> &lt;body> &lt;canvas id="myCanvas" width="200" height="100" style="border:1px solid #000000;"> &lt;/canvas> &lt;/body> &lt;/html> 所以，本质上我要做的就是用 Rust/WASM 代码 或者 JavaScript 代码，控制这个 &lt;canvas id="myCanvas" ，并且定期刷新，这样就能显示动画效果了。 如果你是个 JavaScript 高手，并且打算全部用 JavaScript 实现，那么现在就可以开始动手了。
但如果是 Rust WASM 的方式，还需要考虑下是 纯 WASM 实现呢？ 还是 WASM 实现核心算法逻辑，JavaScript 实现画图这样的组合方式？...</p></div><footer class=entry-footer><span title='2022-03-06 00:00:00 +0000 UTC'>2022-03-06</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rust WASM 自制俄罗斯方块游戏" href=https://runzhen.github.io/posts/tetris-game-in-rust/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Rust 异步 async 和 tokio</h2></header><div class=entry-content><p>快速入门 Rust 语言原生提供了异步操作的关键字 async 和 await，但通常还需要配合第三方的 runtime，其中最有名的就是 tokio 了。
在开始了解 Rust 的所谓异步是什么样子之前，先看一下如何写一个简单的 Rust 异步程序。
以下是 main.rs
async fn hello_world() { hello_cat().await; println!("hello, world!"); } async fn hello_cat() { println!("hello, kitty!"); } #[tokio::main] async fn main() { let future = hello_world(); println!("start"); future.await; } Cargo.toml 文件中加入一行
[dependencies] tokio = { version = "1", features = ["full"] } 运行上面的代码，会看到这样的输出
start hello, kitty! hello, world! 可以看出，future = hello_world(); 是创建一个异步执行的代码块， 并把它赋值给了 future 变量，这个代码块不会立刻执行，而是等到用户调用 await 的时候再去执行。...</p></div><footer class=entry-footer><span title='2022-02-27 00:00:00 +0000 UTC'>2022-02-27</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rust 异步 async 和 tokio" href=https://runzhen.github.io/posts/rust-async-and-tokio/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DDIA 第九章 一致性和共识</h2></header><div class=entry-content><p>一致性保证 本章主要包含了以下话题：
常用的强一致性模型：线性一致性，的优点和缺点。 分布式系统中的事件顺序，特别是因果关系和全局顺序的问题。 如何原子的提交分布式事务，也就是说如何解决共识问题。 线性一致性 哪些地方依赖于线性一致性呢 ？
Locking 服务和 leader election，比如加锁出错了会导致两个人同时写同一个文件。 账户余额，产品库存信息，比如产品超卖。 如何实现一个线性一致性系统 在分布式系统里面，产生不一致的根本原因是因为数据有多个副本，而更新这些副本不是原子操作。
以下是几种多副本系统，能否实现线性一致性的比较：
Single-leader replication (可能线性一致) 这里我猜作者说的是传统 MySQL 这样的主从复制技术。 Consensus Algorithms (线性一致) 这里应该就是常说的 Panox 和 Raft 了。 Multi-leader replication (非线性一致) Leaderless replication (也许不是线性一致的) Dynamo 风格 和 Cassandra 风格。 线性一致的代价 假设两个 datacenter 之间网络断了的情况下，
如果是 multi-leader 系统，那么每个 datacenter 仍然可以独立运行，datacenter 之间的数据是异步同步的，所以不会受到影响。 如果是 single-leader 系统，如果 client 连到了全是 follower 的 datacenter，那么所有 write 和 linerizable read 都受影响，如果 client 连到的是 leader 所在的 datacenter，则不受影响。 CAP Consistency, Availability, Partition Tolerance....</p></div><footer class=entry-footer><span title='2022-02-20 00:00:00 +0000 UTC'>2022-02-20</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DDIA 第九章 一致性和共识" href=https://runzhen.github.io/posts/ddia-ch9-consistency-and-consensus/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Makefile 的几个语法坑</h2></header><div class=entry-content><p>Makefile 和 Bash script 在使用的过程中有很多奇奇怪怪的坑，本文做一下纪录。
首先，有两个文件，一个叫 envs，里面定义了一个环境变量，比如
$ cat envs
export GOPROXY="test.local" 第二个文件就是 Makefile ，假如我这样写
test: source ./envs echo ${GOPROXY} 所以，总的目标是，我希望在 Makefile 中导入另一个文件中事先定义好的环境变量。 然而这样的写法有很多问题。
source 命令找不到 加入直接运行 make, 很有可能你会看到这样的错误
$ make source ./envs make: source: Command not found 可是在 terminal 里面明明可以用 source 命令啊？ 于是，第一个坑出现:
source is a (non-POSIX) shell builtin, not an executable program on any conventional UNIX-like system. If source is changed to ., make changes its strategy; instead of trying to find and execute a program, it just passes the rule body to the system shell....</p></div><footer class=entry-footer><span title='2021-09-26 00:00:00 +0000 UTC'>2021-09-26</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Makefile 的几个语法坑" href=https://runzhen.github.io/posts/makefile-syntax-pitfalls/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Gin HTTP 框架学习笔记</h2></header><div class=entry-content><p>最近要做一个 REST API server，在网上搜索了一遍以后，发现常用的是 Gin 和 Echo，并且很多人都说 golang 本身提供的 http server 已经足够强大，gin 和 echo 也只是在外包了一层。
我看 Gin 的源码行数比 Echo 少很多，而且测试覆盖率也高很多，因此决定学习一下 Gin，本文目标有以下这些
学习如何设计一个 REST 风格的 server ？ 学习 Gin 在 go 自带的 http server 基础上做了哪些工作？ 启动 Gin http server 在使用 Gin 框架的时候，最后都会调用 gin.Run(":8080") ，这样你的 http server 就可以就收 client 请求了，
func (engine *Engine) Run(addr ...string) (err error) { defer func() { debugPrintError(err) }() address := resolveAddress(addr) debugPrint("Listening and serving HTTP on %s\n", address) err = http....</p></div><footer class=entry-footer><span title='2021-09-03 00:00:00 +0000 UTC'>2021-09-03</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Gin HTTP 框架学习笔记" href=https://runzhen.github.io/posts/gin-framework/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>错误使用 time.After() 导致内存泄漏</h2></header><div class=entry-content><p>今天看到了一篇有关 timer 泄露的文章，觉得很有意思，于是把它记录下来。
一般没有问题的写法 说道 time.After() 会导致内存泄露，很多人一定会觉得奇怪，因为代码里经常会用到它，也没见有内存泄漏啊？
是的，一般我们这样写的话是没有问题的
func main() { ch := make(chan int) go func() { ch &lt;- 1 }() select { case _ = &lt;-ch: case &lt;-time.After(time.Second * 1): fmt.Println("timeout") } } 有问题的写法 那么，什么样的写法有问题呢？ 当使用 for loop 的时候，比如这样
for { select { case _ = &lt;-ch: // do something... continue case &lt;-time.After(300 * time.Millisecond): fmt.Printf("time.After() fire！\n") } } 很不幸的是，上面这样的写法也非常常见，我自己就写过这样的代码。那么它真的会造成内存泄露吗？试一下便知道
前一篇博客中已经介绍了如何使用 pprof 对 Go 程序进行 profiling，简单提一下步骤
在代码中引入 _ "net/http/pprof", 并开启一个http server 导出 metrics 运行你的 binary 执行 go tool pprof -http=:8081 http://localhost:6060/debug/pprof/heap 浏览器就会自动打开 localhost:8081 显示结果了 测试代码如下：...</p></div><footer class=entry-footer><span title='2021-08-08 00:00:00 +0000 UTC'>2021-08-08</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 错误使用 time.After() 导致内存泄漏" href=https://runzhen.github.io/posts/golang-timer-leak/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>k8s 切换 namespace 以及命令补全</h2></header><div class=entry-content><p>本文可以学到
.kube/config 文件中有哪些内容 如何实现 bash 的命令补全功能 起因 在使用 kubectl 命令的过程中，经常需要查看不同 namespace 下的资源，因此命令经常需要带上 -n name。
如果不想每次都多打这些字符，也可以设置一个默认的 namespace，
kubectl config set-context --current --namespace=xxxx 这样是方便了不少，但是一旦切换了 namespace 之后，又要重复上面的命令，而且经常还不记得。
有没有更好的办法呢？ 有人开发了一个小工具，kubectx 专门用于方便的切换 ctx 和 namespace。 ctx 是什么呢？ 其实就是哪个 k8s 集群。 说白了就是让你方便的在多个集群和 namespace 之间切换。
kubectx 有两种实现，一开始用的是最简单的 bash shell 脚本，新的版本开始用 k8s client API 开发。 下文的分析仅仅关注 namespace 的切换。
shell 版本的实现 这个实现非常简单，本质上就是调用几个 kubectl 命令实现 ns 切换。
首先需要知道的是，在 ~/.kube/config 路径下的 config 记录了你配置 kubectl 的信息，比如你用 kubectl 操作过几个 k8s 都会纪录在里面。
apiVersion: v1 clusters: - cluster: certificate-authority-data: DATA+OMITTED server: https://10....</p></div><footer class=entry-footer><span title='2021-08-01 00:00:00 +0000 UTC'>2021-08-01</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to k8s 切换 namespace 以及命令补全" href=https://runzhen.github.io/posts/k8s-set-namespace-tool/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang pprof 的使用姿势</h2></header><div class=entry-content><p>首先，在代码中引入 pprof 的方式非常简单，只要把下面这段代码放到 main 函数中即可
_ "net/http/pprof" go func() { if err := http.ListenAndServe(":9090", nil); err != nil { panic(err) } os.Exit(0) }() 然后启动你的程序，再用以下这些命令去对应的端口做 profiling
// cpu profile 默认从当前开始收集 30s 的 cpu 使用情况，需要等待 30s go tool pprof http://47.93.238.9:9090/debug/pprof/profile # wait 120s go tool pprof http://47.93.238.9:9090/debug/pprof/profile?seconds=120 // 以下 second 参数不起作用，因为采样是一瞬间完成的 go tool pprof http://47.93.238.9:9090/debug/pprof/heap go tool pprof http://47.93.238.9:9090/debug/pprof/goroutine go tool pprof http://47.93.238.9:9090/debug/pprof/block go tool pprof http://47.93.238.9:9090/debug/pprof/mutex 还有一种是 import "runtime/pprof“的方式，这种不太常用，不在本文范围。
运行了 go tool pprof 命令以后，会进入到一个交互界面，...</p></div><footer class=entry-footer><span title='2021-07-18 00:00:00 +0000 UTC'>2021-07-18</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Golang pprof 的使用姿势" href=https://runzhen.github.io/posts/golang-pprof-usage/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Rust 入坑之 LRU Cache</h2></header><div class=entry-content><p>lru 算法的原理简而言之就是一个 hash ，一个 double linked list
Linked List 提供 O(1) 的复杂度对元素进行插入和删除 hash 提供 O(1) 的复杂度进行查找 本文主要是通过阅读一个 rust 实现的 lru 学习相关语法。
如何在结构体里面使用指针？ rust 是否有 raw pointer 直接指向内存地址，如果能用该怎么用？ Linked List 节点结构体 上面提到，真正的 key/value 是存在双链表的 Node 里，所以需要先定义这个 Node 长什么样，lru-rs 中 LruEntry 表示的就是 node：
K V 代表的是泛型的类型， struct LruEntry&lt;K, V> { key: mem::MaybeUninit&lt;K>, val: mem::MaybeUninit&lt;V>, prev: *mut LruEntry&lt;K, V>, next: *mut LruEntry&lt;K, V>, } 下面是如何初始化一个 Node，
impl&lt;K, V> LruEntry&lt;K, V> { fn new(key: K, val: V) -> Self { LruEntry { key: mem::MaybeUninit::new(key), val: mem::MaybeUninit::new(val), prev: ptr::null_mut(), next: ptr::null_mut(), } } fn new_sigil() -> Self { LruEntry { key: mem::MaybeUninit::uninit(), val: mem::MaybeUninit::uninit(), prev: ptr::null_mut(), next: ptr::null_mut(), } } } key value 用 mem::MaybeUninit::new(key)进行初始化 prev next 指针用 ptr::null_mut() 初始化 LRU cache 结构体 链表的 node 定义好以后，双链表结构也自然而然就有了。接下来还缺一个 map 结构体，这个可以用 rust 原生的 hash 函数库，然后就可以定义出 LRU 结构体...</p></div><footer class=entry-footer><span title='2021-07-11 00:00:00 +0000 UTC'>2021-07-11</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rust 入坑之 LRU Cache" href=https://runzhen.github.io/posts/rust-lru-cache/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://runzhen.github.io/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://runzhen.github.io/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://runzhen.github.io/>Mind in the Wind</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>