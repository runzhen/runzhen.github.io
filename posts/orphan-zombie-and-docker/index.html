<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Orphan, Zombie and Docker | Mind in the Wind</title>
<meta name=keywords content="linux,docker"><meta name=description content='孤儿进程的产生 孤儿进程： 父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。通常，孤儿进程将被进程号为1的进程(进程号为 1 的是 init 进程)所收养，并由该进程调用 wait 对孤儿进程收尸。
#include <stdio.h> #include <stdlib.h> #include <errno.h> #include <unistd.h> int main() { pid_t pid; pid = fork(); if (pid == 0) { printf("I&#39;m child process, pid:%d ppid:%d\n", getpid(), getppid()); sleep(5); printf("I&#39;m child process, pid:%d ppid:%d\n", getpid(), getppid()); } else { printf("I&#39;m father process, pid:%d ppid:%d\n", getpid(), getppid()); sleep(1); printf("father process is exited.\n"); } return 0; } 运行结果如下所示：
I&#39;m father process, pid:25354 ppid:13981I&#39;m child process, pid:25355 ppid:25354father process is exited.'><meta name=author content="Me"><link rel=canonical href=https://runzhen.github.io/posts/orphan-zombie-and-docker/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.a8f620eb24ba9442cd3765590f9208a0752be50e5a7b9dd9e3e555c8cb5e74e6.css integrity="sha256-qPYg6yS6lELNN2VZD5IIoHUr5Q5ae53Z4+VVyMtedOY=" rel="preload stylesheet" as=style><link rel=icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://runzhen.github.io/posts/orphan-zombie-and-docker/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Orphan, Zombie and Docker"><meta property="og:description" content='孤儿进程的产生 孤儿进程： 父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。通常，孤儿进程将被进程号为1的进程(进程号为 1 的是 init 进程)所收养，并由该进程调用 wait 对孤儿进程收尸。
#include <stdio.h> #include <stdlib.h> #include <errno.h> #include <unistd.h> int main() { pid_t pid; pid = fork(); if (pid == 0) { printf("I&#39;m child process, pid:%d ppid:%d\n", getpid(), getppid()); sleep(5); printf("I&#39;m child process, pid:%d ppid:%d\n", getpid(), getppid()); } else { printf("I&#39;m father process, pid:%d ppid:%d\n", getpid(), getppid()); sleep(1); printf("father process is exited.\n"); } return 0; } 运行结果如下所示：
I&#39;m father process, pid:25354 ppid:13981I&#39;m child process, pid:25355 ppid:25354father process is exited.'><meta property="og:type" content="article"><meta property="og:url" content="https://runzhen.github.io/posts/orphan-zombie-and-docker/"><meta property="og:image" content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-06-16T00:00:00+00:00"><meta property="article:modified_time" content="2019-06-16T00:00:00+00:00"><meta property="og:site_name" content="Mind in the Wind"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Orphan, Zombie and Docker"><meta name=twitter:description content='孤儿进程的产生 孤儿进程： 父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。通常，孤儿进程将被进程号为1的进程(进程号为 1 的是 init 进程)所收养，并由该进程调用 wait 对孤儿进程收尸。
#include <stdio.h> #include <stdlib.h> #include <errno.h> #include <unistd.h> int main() { pid_t pid; pid = fork(); if (pid == 0) { printf("I&#39;m child process, pid:%d ppid:%d\n", getpid(), getppid()); sleep(5); printf("I&#39;m child process, pid:%d ppid:%d\n", getpid(), getppid()); } else { printf("I&#39;m father process, pid:%d ppid:%d\n", getpid(), getppid()); sleep(1); printf("father process is exited.\n"); } return 0; } 运行结果如下所示：
I&#39;m father process, pid:25354 ppid:13981I&#39;m child process, pid:25355 ppid:25354father process is exited.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://runzhen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Orphan, Zombie and Docker","item":"https://runzhen.github.io/posts/orphan-zombie-and-docker/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Orphan, Zombie and Docker","name":"Orphan, Zombie and Docker","description":"孤儿进程的产生 孤儿进程： 父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。通常，孤儿进程将被进程号为1的进程(进程号为 1 的是 init 进程)所收养，并由该进程调用 wait 对孤儿进程收尸。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { pid_t pid; pid = fork(); if (pid == 0) { printf(\u0026#34;I\u0026#39;m child process, pid:%d ppid:%d\\n\u0026#34;, getpid(), getppid()); sleep(5); printf(\u0026#34;I\u0026#39;m child process, pid:%d ppid:%d\\n\u0026#34;, getpid(), getppid()); } else { printf(\u0026#34;I\u0026#39;m father process, pid:%d ppid:%d\\n\u0026#34;, getpid(), getppid()); sleep(1); printf(\u0026#34;father process is exited.\\n\u0026#34;); } return 0; } 运行结果如下所示：\nI\u0026#39;m father process, pid:25354 ppid:13981\rI\u0026#39;m child process, pid:25355 ppid:25354\rfather process is exited.","keywords":["linux","docker"],"articleBody":"孤儿进程的产生 孤儿进程： 父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。通常，孤儿进程将被进程号为1的进程(进程号为 1 的是 init 进程)所收养，并由该进程调用 wait 对孤儿进程收尸。\n#include #include #include #include int main() { pid_t pid; pid = fork(); if (pid == 0) { printf(\"I'm child process, pid:%d ppid:%d\\n\", getpid(), getppid()); sleep(5); printf(\"I'm child process, pid:%d ppid:%d\\n\", getpid(), getppid()); } else { printf(\"I'm father process, pid:%d ppid:%d\\n\", getpid(), getppid()); sleep(1); printf(\"father process is exited.\\n\"); } return 0; } 运行结果如下所示：\nI'm father process, pid:25354 ppid:13981\rI'm child process, pid:25355 ppid:25354\rfather process is exited.\rI'm child process, pid:25355 ppid:1 一般来说，孤儿进程并没有什么危害，因为当孤儿进程结束的时候，init 进程会调用 wait 来处理。\n但是当到了 Docker 环境下是不是还是这样呢？ 本文第三节再详细说明。\n僵尸进程的产生 僵尸进程： 子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，直到它的父进程退出。\n僵尸进程因为一直占据进程描述符等信息，如果它的父进程是长期运行不退出的话，僵尸进程就会一直占用系统资源。\n#include #include #include #include int main() { pid_t pid; pid = fork(); if (pid == 0) { printf(\"I am child process - %d. I am exiting.\\n\", getpid()); exit(0); } printf(\"I am father process- %d. I'm sleeping....\\n\", getpid()); /* 等待子进程先退出 */ sleep(10); printf(\"father process - %d is exiting.\\n\", getpid()); return 0; } 这段代码中，子进程立刻退出变成 zombie，父进程等待 10 秒，所以在这 10 秒钟内，我们能观察到这个 zombie 的存在。\n打开一个 terminal，运行上面的代码，\n$ ./demo-zombie I am father process- 11714. I'm sleeping.... I am child process - 11715. I am exiting. father process - 11714 is exiting. 同时，在另一个 terminal 里面我们用 ps 命令输出进程树结构关系：\n$ps xf -opid,ppid,stat,args 13980 1 Ss tmux new-session -s ssh_tmux 13981 13980 Ss \\_ -bash 11714 13981 S+ | \\_ ./demo-zombie 11715 11714 Z+ | \\_ [demo-zombie] 8712 13980 Ss \\_ -bash 11855 8712 R+ \\_ ps xf -opid,ppid,stat,args 10 秒钟过后，父进程也退出了，zombie 于是被 init 进程收养。\n因为 init 进程会用 wait 为 zombie 收尸，于是 10 秒钟过后，系统中将没有这个僵尸进程了。\nDocker 中的孤儿进程 上面所说的僵尸进程和孤儿进程都是非 docker 环境中，那么在 docker 里有 init 进程吗 ？ 孤儿进程会被谁收养呢？\n无论在不在 docker 中，我们先来看一下 linux 如何选择谁来做孤儿进程的 parent。\n孤儿进程被谁接管？ 看一下 Linux 内核中关于接收孤儿进程的代码\n/* * When we die, we re-parent all our children, and try to: * 1. give them to another thread in our thread group, if such a member exists * 2. give it to the first ancestor process which prctl'd itself as a * child_subreaper for its children (like a service manager) * 3. give it to the init process (PID 1) in our pid namespace */ static struct task_struct *find_new_reaper(struct task_struct *father, struct task_struct *child_reaper) {} 函数的注释部分说的非常清楚：\n首先尝试找到相同线程组里其他可用的线程。 如果用 prctl 设置了 child_subreaper，那么找到这个最近的 child_subreaper。 如果上面两步都失败，则选择该 namespace 下的 init 进程（pid 为 1） 收养这个孤儿进程。 PR_SET_CHILD_SUBREAPER prctl 顾名思义就是 process control 的缩写。其中关于 PR_SET_CHILD_SUBREAPER 部分的说明如下\nPR_SET_CHILD_SUBREAPER (since Linux 3.4)\rA subreaper fulfills the role of init(1) for its descendant\rprocesses. When a process becomes orphaned (i.e., its\rimmediate parent terminates) then that process will be\rreparented to the nearest still living ancestor subreaper.\rSubsequently, calls to getppid() in the orphaned process will\rnow return the PID of the subreaper process, and when the\rorphan terminates, it is the subreaper process that will\rreceive a SIGCHLD signal and will be able to wait(2) on the\rprocess to discover its termination status.\rThe setting of the \"child subreaper\" attribute is not\rinherited by children created by fork(2) and clone(2). The\rsetting is preserved across execve(2).\rEstablishing a subreaper process is useful in session\rmanagement frameworks where a hierarchical group of processes\ris managed by a subreaper process that needs to be informed\rwhen one of the processes—for example, a double-forked daemon—\rterminates (perhaps so that it can restart that process).\rSome init(1) frameworks (e.g., systemd(1)) employ a subreaper\rprocess for similar reasons. 当一个进程调用 prctl 设置了这个参数以后，它的子进程都被标记为拥有一个 subreaper。当某个子进程成为了孤儿进程，那么会沿着进程树向祖先找一个最近的是 child_subreaper 并且运行着的进程，这个进程将会接管这个孤儿进程。\nDocker 中的 pid = 1 进程 由上面的分析我们知道了，如果产生了孤儿进程，系统首先尝试找它的祖先进程树种找到一个合适的父进程，实在找不到才分配 pid = 1 的进程给它。\n这么做通常没有问题，因为一般来收系统的 pid 1 进程是 init 进程，init 会对子进程调用 wait()，因此不会产生僵尸进程。\n那么在 docker 还是这样吗？ 我们先启动一个 docker 运行 sleep 1000 秒，然后再进入到容器中查看进程树。\n$ docker run -d --name ubuntu ubuntu:latest sleep 1000 11eff3a64d76760366a6056e1eaaacada07e840c6ee896c47f4d57be62c92d5f $ docker exec -it 11eff3a6 /bin/bash root@11eff3a64d76:/# ps xf -opid,ppid,args PID PPID COMMAND 8 0 /bin/bash 22 8 \\_ ps xf -opid,ppid,args 1 0 sleep 1000 可以看到，容器内根本没有 init 进程，PID 为 1 的是 sleep 进程，很显然，这个简单的 sleep 进程是不会调用 wait 去给子进程收尸的。\nDocker 中孤儿进程会变成僵尸吗？ 如果我们故意在容器内产生一个孤儿进程，是不是它的父进程就会被设置为 sleep 进程，又因为 sleep 没有 wait，所以最后产生僵尸进程呢？\n我们再来做一个实验，\n首先，用 docker 启动一个 sleep 程序，它的 PID 为 1. 然后，把第一节中产生孤儿进程的程序挂载到 docker $docker run -d -rm --name ubuntu -v `pwd`:/root/ ubuntu:latest sleep 1000 $docker exec -it ubuntu /bin/bash $./orphan 非常幸运的是，我的两台机器上都安装 Docker，其中一个版本较新，另一个版本比较旧，运行同样的程序，看到了两种截然不同的结果。\n旧的版本上，产生的孤儿进程 PPID = 1，是 sleep 进程。所以当孤儿进程结束后，sleep 显然不会给它收尸，所以产生了僵尸进程。\n当多次运行这个程序后，可以看到，容器内产生了大量僵尸进程。\nroot@b175b45416ca:~# ./orphan I'm father process, pid:49 ppid:8 I'm child process, pid:50 ppid:49 I'm child process, pid:50 ppid:1 root@b175b45416ca:~# ps xf -opid,ppid,stat,args PID PPID STAT COMMAND 8 0 Ss /bin/bash 51 8 R+ \\_ ps xf -opid,ppid,stat,args 1 0 Ss sleep 1000 20 1 Z [orphan] 30 1 Z [orphan] 33 1 Z [orphan] 35 1 Z [orphan] 37 1 Z [orphan] 39 1 Z [orphan] 41 1 Z [orphan] 43 1 Z [orphan] 45 1 Z [orphan] 50 1 S ./orphan 相反在较新的 Docker 中，孤儿进程 PPID = 0，多次运行程序后，容器内没有产生僵尸进程。\nroot@9c0cd97e5da0:~# ./orphan I'm father process, pid:30 ppid:20 I'm child process, pid:31 ppid:30 root@9c0cd97e5da0:~# ps xf -opid,ppid,stat,args PID PPID STAT COMMAND 31 0 S ./orphan 20 0 Ss /bin/bash 32 20 R+ \\_ ps xf -opid,ppid,stat,args 1 0 Ss sleep 1000 root@9c0cd97e5da0:~# I'm child process, pid:31 ppid:0 由此可见，新版本的 docker engine 中正确处理了产生僵尸进程的问题。\n如何避免僵尸进程 直接 wait 这是最简单的方法，父进程直接调用 wait/waitpid 函数等待子进程退出。这是最简单明了的展示如何使用 wait 给子进程收尸的例子。\n#include #include #include #include #include int main(void) { pid_t pid; pid = fork(); if (pid == 0) { printf(\"This is the child\\n\"); sleep(5); exit(3); } else { //父进程 int stat_val; waitpid(pid, \u0026stat_val, 0); /*阻塞等待子进程*/ if (WIFEXITED(stat_val)) { printf(\"Child exited with code %d\\n\", WEXITSTATUS(stat_val)); } else if (WIFSIGNALED(stat_val)) { printf(\"Child terminated abnormally, signal %d\\n\", WTERMSIG(stat_val)); } } return 0; } 然而直接调用 wait 是阻塞的，父进程一直在等待直到 wait 返回，它才能做其他事。显然在实际开发中不能用这样的方法。\n通过信号机制 子进程退出时会自动向父进程发送 SIGCHILD 信号，父进程先为 SIGCHILD信号注册处理函数。在信号处理函数中调用wait进行处理僵尸进程。\n这样父进程就不用等待子进程退出，可以继续做自己的事。\n#include #include #include #include #include static void sig_child(int signo); int main() { pid_t pid; //创建捕捉子进程退出信号 signal(SIGCHLD,sig_child); pid = fork(); if (pid == 0) { printf(\"I am child process,pid id %d.I am exiting.\\n\", getpid()); exit(0); } printf(\"I am father process.I will sleep two seconds\\n\"); //等待子进程先退出 sleep(5); //输出进程信息 system(\"ps -o pid,ppid,state,tty,command\"); printf(\"father process is exiting.\\n\"); return 0; } static void sig_child(int signo) { pid_t pid; int stat; //处理僵尸进程 while ((pid = waitpid(-1, \u0026stat, WNOHANG)) \u003e0) printf(\"child %d terminated.\\n\", pid); } fork() 两次 原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程处理僵尸进程。代码的逻辑结构大致如下:\nint main() { pid_t pid; //创建第一个子进程 pid = fork(); if (pid \u003c 0) { perror(\"fork error:\"); exit(1); } else if (pid == 0) { pid = fork(); if (pid \u003e0) { printf(\"first procee is exited.\\n\"); exit(0); } //第二个子进程 do_something(); } //父进程处理第一个子进程退出 if (waitpid(pid, NULL, 0) != pid) { perror(\"waitepid error:\"); exit(1); } return 0; } 参考资料 https://www.cnblogs.com/Anker/p/3271773.html https://yq.aliyun.com/articles/61894 https://adoyle.me/blog/orphaned-process-and-zombie-process-and-docker.html https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/ 新旧 Docker 版本信息\n$docker version\r新版本\rServer: Docker Engine - Community\rEngine:\rVersion: 18.09.6\rAPI version: 1.39 (minimum version 1.12)\rGo version: go1.10.8\rGit commit: 481bc77\rBuilt: Sat May 4 01:59:36 2019\rOS/Arch: linux/amd64\rExperimental: false\r旧版本\rServer:\rEngine:\rVersion: 18.06.1-ce\rAPI version: 1.38 (minimum version 1.12)\rGo version: go1.10.1\rGit commit: e68fc7a\rBuilt: Thu Jan 24 10:49:48 2019\rOS/Arch: linux/amd64\rExperimental: false ","wordCount":"1100","inLanguage":"en","image":"https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2019-06-16T00:00:00Z","dateModified":"2019-06-16T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://runzhen.github.io/posts/orphan-zombie-and-docker/"},"publisher":{"@type":"Organization","name":"Mind in the Wind","logo":{"@type":"ImageObject","url":"https://runzhen.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://runzhen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://runzhen.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://runzhen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://runzhen.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://runzhen.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://runzhen.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Orphan, Zombie and Docker</h1><div class=post-meta><span title='2019-06-16 00:00:00 +0000 UTC'>2019-06-16</span>&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b%e7%9a%84%e4%ba%a7%e7%94%9f aria-label=孤儿进程的产生>孤儿进程的产生</a></li><li><a href=#%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e7%9a%84%e4%ba%a7%e7%94%9f aria-label=僵尸进程的产生>僵尸进程的产生</a></li><li><a href=#docker-%e4%b8%ad%e7%9a%84%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b aria-label="Docker 中的孤儿进程">Docker 中的孤儿进程</a><ul><li><a href=#%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b%e8%a2%ab%e8%b0%81%e6%8e%a5%e7%ae%a1 aria-label=孤儿进程被谁接管？>孤儿进程被谁接管？</a></li><li><a href=#pr_set_child_subreaper aria-label=PR_SET_CHILD_SUBREAPER>PR_SET_CHILD_SUBREAPER</a></li><li><a href=#docker-%e4%b8%ad%e7%9a%84-pid--1-%e8%bf%9b%e7%a8%8b aria-label="Docker 中的 pid = 1 进程">Docker 中的 pid = 1 进程</a></li><li><a href=#docker-%e4%b8%ad%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b%e4%bc%9a%e5%8f%98%e6%88%90%e5%83%b5%e5%b0%b8%e5%90%97 aria-label="Docker 中孤儿进程会变成僵尸吗？">Docker 中孤儿进程会变成僵尸吗？</a></li></ul></li><li><a href=#%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b aria-label=如何避免僵尸进程>如何避免僵尸进程</a><ul><li><a href=#%e7%9b%b4%e6%8e%a5-wait aria-label="直接 wait">直接 wait</a></li><li><a href=#%e9%80%9a%e8%bf%87%e4%bf%a1%e5%8f%b7%e6%9c%ba%e5%88%b6 aria-label=通过信号机制>通过信号机制</a></li><li><a href=#fork-%e4%b8%a4%e6%ac%a1 aria-label="fork() 两次">fork() 两次</a></li></ul></li><li><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a></li></ul></div></details></div><div class=post-content><h2 id=孤儿进程的产生>孤儿进程的产生<a hidden class=anchor aria-hidden=true href=#孤儿进程的产生>#</a></h2><p>孤儿进程： 父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。通常，孤儿进程将被进程号为1的进程(进程号为 1 的是 init 进程)所收养，并由该进程调用 wait 对孤儿进程收尸。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;I&#39;m child process, pid:%d  ppid:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>(),</span> <span class=nf>getppid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;I&#39;m child process, pid:%d  ppid:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>(),</span> <span class=nf>getppid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;I&#39;m father process, pid:%d  ppid:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>(),</span> <span class=nf>getppid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;father process is  exited.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>运行结果如下所示：</p><pre tabindex=0><code>I&#39;m father process, pid:25354  ppid:13981
I&#39;m child process, pid:25355  ppid:25354
father process is  exited.

I&#39;m child process, pid:25355  ppid:1
</code></pre><p>一般来说，孤儿进程并没有什么危害，因为当孤儿进程结束的时候，init 进程会调用 wait 来处理。</p><p>但是当到了 Docker 环境下是不是还是这样呢？ 本文第三节再详细说明。</p><h2 id=僵尸进程的产生>僵尸进程的产生<a hidden class=anchor aria-hidden=true href=#僵尸进程的产生>#</a></h2><p>僵尸进程： 子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，直到它的父进程退出。</p><p>僵尸进程因为一直占据进程描述符等信息，如果它的父进程是长期运行不退出的话，僵尸进程就会一直占用系统资源。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;I am child process - %d. I am exiting.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;I am father process- %d. I&#39;m sleeping....</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 等待子进程先退出 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>sleep</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;father process - %d is exiting.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这段代码中，子进程立刻退出变成 zombie，父进程等待 10 秒，所以在这 10 秒钟内，我们能观察到这个 zombie 的存在。</p><p>打开一个 terminal，运行上面的代码，</p><pre tabindex=0><code>$ ./demo-zombie                           
I am father process- 11714. I&#39;m sleeping....    
I am child process - 11715. I am exiting.  
father process - 11714 is exiting.
</code></pre><p>同时，在另一个 terminal 里面我们用 ps 命令输出进程树结构关系：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>$ps</span> xf -opid,ppid,stat,args
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=m>13980</span>     <span class=m>1</span> Ss   tmux new-session -s ssh_tmux
</span></span><span class=line><span class=cl><span class=m>13981</span> <span class=m>13980</span> Ss    <span class=se>\_</span> -bash
</span></span><span class=line><span class=cl><span class=m>11714</span> <span class=m>13981</span> S+    <span class=p>|</span>   <span class=se>\_</span> ./demo-zombie
</span></span><span class=line><span class=cl><span class=m>11715</span> <span class=m>11714</span> Z+    <span class=p>|</span>       <span class=se>\_</span> <span class=o>[</span>demo-zombie<span class=o>]</span> &lt;defunct&gt;
</span></span><span class=line><span class=cl> <span class=m>8712</span> <span class=m>13980</span> Ss    <span class=se>\_</span> -bash
</span></span><span class=line><span class=cl><span class=m>11855</span>  <span class=m>8712</span> R+        <span class=se>\_</span> ps xf -opid,ppid,stat,args
</span></span></code></pre></div><p>10 秒钟过后，父进程也退出了，zombie 于是被 init 进程收养。</p><p>因为 init 进程会用 wait 为 zombie 收尸，于是 10 秒钟过后，系统中将没有这个僵尸进程了。</p><h2 id=docker-中的孤儿进程>Docker 中的孤儿进程<a hidden class=anchor aria-hidden=true href=#docker-中的孤儿进程>#</a></h2><p>上面所说的僵尸进程和孤儿进程都是非 docker 环境中，那么在 docker 里有 init 进程吗 ？ 孤儿进程会被谁收养呢？</p><p>无论在不在 docker 中，我们先来看一下 linux 如何选择谁来做孤儿进程的 parent。</p><h3 id=孤儿进程被谁接管>孤儿进程被谁接管？<a hidden class=anchor aria-hidden=true href=#孤儿进程被谁接管>#</a></h3><p>看一下 Linux 内核中关于接收孤儿进程的<a href=https://github.com/torvalds/linux/blob/eae21770b4fed5597623aad0d618190fa60426ff/kernel/exit.c#L479>代码</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * When we die, we re-parent all our children, and try to:
</span></span></span><span class=line><span class=cl><span class=cm> * 1. give them to another thread in our thread group, if such a member exists
</span></span></span><span class=line><span class=cl><span class=cm> * 2. give it to the first ancestor process which prctl&#39;d itself as a
</span></span></span><span class=line><span class=cl><span class=cm> *    child_subreaper for its children (like a service manager)
</span></span></span><span class=line><span class=cl><span class=cm> * 3. give it to the init process (PID 1) in our pid namespace
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=nf>find_new_reaper</span><span class=p>(</span><span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>father</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>child_reaper</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{}</span>
</span></span></code></pre></div><p>函数的注释部分说的非常清楚：</p><ol><li>首先尝试找到相同线程组里其他可用的线程。</li><li>如果用 prctl 设置了 child_subreaper，那么找到这个最近的 child_subreaper。</li><li>如果上面两步都失败，则选择该 namespace 下的 init 进程（pid 为 1） 收养这个孤儿进程。</li></ol><h3 id=pr_set_child_subreaper>PR_SET_CHILD_SUBREAPER<a hidden class=anchor aria-hidden=true href=#pr_set_child_subreaper>#</a></h3><p><a href=http://man7.org/linux/man-pages/man2/prctl.2.html>prctl</a> 顾名思义就是 process control 的缩写。其中关于 PR_SET_CHILD_SUBREAPER 部分的说明如下</p><pre tabindex=0><code>PR_SET_CHILD_SUBREAPER (since Linux 3.4)

              A subreaper fulfills the role of init(1) for its descendant
              processes.  When a process becomes orphaned (i.e., its
              immediate parent terminates) then that process will be
              reparented to the nearest still living ancestor subreaper.
              Subsequently, calls to getppid() in the orphaned process will
              now return the PID of the subreaper process, and when the
              orphan terminates, it is the subreaper process that will
              receive a SIGCHLD signal and will be able to wait(2) on the
              process to discover its termination status.

              The setting of the &#34;child subreaper&#34; attribute is not
              inherited by children created by fork(2) and clone(2).  The
              setting is preserved across execve(2).

              Establishing a subreaper process is useful in session
              management frameworks where a hierarchical group of processes
              is managed by a subreaper process that needs to be informed
              when one of the processes—for example, a double-forked daemon—
              terminates (perhaps so that it can restart that process).
              Some init(1) frameworks (e.g., systemd(1)) employ a subreaper
              process for similar reasons.
</code></pre><p>当一个进程调用 prctl 设置了这个参数以后，它的子进程都被标记为拥有一个 subreaper。当某个子进程成为了孤儿进程，那么会沿着进程树向祖先找一个最近的是 child_subreaper 并且运行着的进程，这个进程将会接管这个孤儿进程。</p><h3 id=docker-中的-pid--1-进程>Docker 中的 pid = 1 进程<a hidden class=anchor aria-hidden=true href=#docker-中的-pid--1-进程>#</a></h3><p>由上面的分析我们知道了，如果产生了孤儿进程，系统首先尝试找它的祖先进程树种找到一个合适的父进程，实在找不到才分配 pid = 1 的进程给它。</p><p>这么做通常没有问题，因为一般来收系统的 pid 1 进程是 init 进程，init 会对子进程调用 wait()，因此不会产生僵尸进程。</p><p>那么在 docker 还是这样吗？ 我们先启动一个 docker 运行 sleep 1000 秒，然后再进入到容器中查看进程树。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ docker run -d --name ubuntu ubuntu:latest sleep <span class=m>1000</span>
</span></span><span class=line><span class=cl>11eff3a64d76760366a6056e1eaaacada07e840c6ee896c47f4d57be62c92d5f
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker <span class=nb>exec</span> -it 11eff3a6 /bin/bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>root@11eff3a64d76:/# ps xf -opid,ppid,args
</span></span><span class=line><span class=cl>  PID  PPID COMMAND
</span></span><span class=line><span class=cl>    <span class=m>8</span>     <span class=m>0</span> /bin/bash
</span></span><span class=line><span class=cl>   <span class=m>22</span>     <span class=m>8</span>  <span class=se>\_</span> ps xf -opid,ppid,args
</span></span><span class=line><span class=cl>    <span class=m>1</span>     <span class=m>0</span> sleep <span class=m>1000</span>
</span></span></code></pre></div><p>可以看到，容器内根本没有 init 进程，PID 为 1 的是 sleep 进程，很显然，这个简单的 sleep 进程是不会调用 wait 去给子进程收尸的。</p><h3 id=docker-中孤儿进程会变成僵尸吗>Docker 中孤儿进程会变成僵尸吗？<a hidden class=anchor aria-hidden=true href=#docker-中孤儿进程会变成僵尸吗>#</a></h3><p>如果我们故意在容器内产生一个孤儿进程，是不是它的父进程就会被设置为 sleep 进程，又因为 sleep 没有 wait，所以最后产生僵尸进程呢？</p><p>我们再来做一个实验，</p><ol><li>首先，用 docker 启动一个 sleep 程序，它的 PID 为 1.</li><li>然后，把第一节中产生孤儿进程的程序挂载到 docker</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>$docker</span> run -d -rm --name ubuntu -v <span class=sb>`</span><span class=nb>pwd</span><span class=sb>`</span>:/root/ ubuntu:latest sleep <span class=m>1000</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>$docker</span> <span class=nb>exec</span> -it ubuntu /bin/bash
</span></span><span class=line><span class=cl>$./orphan
</span></span></code></pre></div><p>非常幸运的是，我的两台机器上都安装 Docker，其中一个版本较新，另一个版本比较旧，运行同样的程序，看到了两种截然不同的结果。</p><p>旧的版本上，产生的孤儿进程 PPID = 1，是 sleep 进程。所以当孤儿进程结束后，sleep 显然不会给它收尸，所以产生了僵尸进程。</p><p>当多次运行这个程序后，可以看到，容器内产生了大量僵尸进程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>root@b175b45416ca:~# ./orphan
</span></span><span class=line><span class=cl>I<span class=s1>&#39;m father process, pid:49  ppid:8
</span></span></span><span class=line><span class=cl><span class=s1>I&#39;</span>m child process, pid:50  ppid:49
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>I<span class=err>&#39;</span>m child process, pid:50  ppid:1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>root@b175b45416ca:~# ps xf -opid,ppid,stat,args
</span></span><span class=line><span class=cl>  PID  PPID STAT COMMAND
</span></span><span class=line><span class=cl>    <span class=m>8</span>     <span class=m>0</span> Ss   /bin/bash
</span></span><span class=line><span class=cl>   <span class=m>51</span>     <span class=m>8</span> R+    <span class=se>\_</span> ps xf -opid,ppid,stat,args
</span></span><span class=line><span class=cl>    <span class=m>1</span>     <span class=m>0</span> Ss   sleep <span class=m>1000</span>
</span></span><span class=line><span class=cl>   <span class=m>20</span>     <span class=m>1</span> Z    <span class=o>[</span>orphan<span class=o>]</span> &lt;defunct&gt;
</span></span><span class=line><span class=cl>   <span class=m>30</span>     <span class=m>1</span> Z    <span class=o>[</span>orphan<span class=o>]</span> &lt;defunct&gt;
</span></span><span class=line><span class=cl>   <span class=m>33</span>     <span class=m>1</span> Z    <span class=o>[</span>orphan<span class=o>]</span> &lt;defunct&gt;
</span></span><span class=line><span class=cl>   <span class=m>35</span>     <span class=m>1</span> Z    <span class=o>[</span>orphan<span class=o>]</span> &lt;defunct&gt;
</span></span><span class=line><span class=cl>   <span class=m>37</span>     <span class=m>1</span> Z    <span class=o>[</span>orphan<span class=o>]</span> &lt;defunct&gt;
</span></span><span class=line><span class=cl>   <span class=m>39</span>     <span class=m>1</span> Z    <span class=o>[</span>orphan<span class=o>]</span> &lt;defunct&gt;
</span></span><span class=line><span class=cl>   <span class=m>41</span>     <span class=m>1</span> Z    <span class=o>[</span>orphan<span class=o>]</span> &lt;defunct&gt;
</span></span><span class=line><span class=cl>   <span class=m>43</span>     <span class=m>1</span> Z    <span class=o>[</span>orphan<span class=o>]</span> &lt;defunct&gt;
</span></span><span class=line><span class=cl>   <span class=m>45</span>     <span class=m>1</span> Z    <span class=o>[</span>orphan<span class=o>]</span> &lt;defunct&gt;
</span></span><span class=line><span class=cl>   <span class=m>50</span>     <span class=m>1</span> S    ./orphan
</span></span></code></pre></div><p>相反在较新的 Docker 中，孤儿进程 PPID = 0，多次运行程序后，容器内没有产生僵尸进程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>root@9c0cd97e5da0:~# ./orphan
</span></span><span class=line><span class=cl>I<span class=s1>&#39;m father process, pid:30  ppid:20
</span></span></span><span class=line><span class=cl><span class=s1>I&#39;</span>m child process, pid:31  ppid:30
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>root@9c0cd97e5da0:~# ps xf -opid,ppid,stat,args
</span></span><span class=line><span class=cl>  PID  PPID STAT COMMAND
</span></span><span class=line><span class=cl>   <span class=m>31</span>     <span class=m>0</span> S    ./orphan
</span></span><span class=line><span class=cl>   <span class=m>20</span>     <span class=m>0</span> Ss   /bin/bash
</span></span><span class=line><span class=cl>   <span class=m>32</span>    <span class=m>20</span> R+    <span class=se>\_</span> ps xf -opid,ppid,stat,args
</span></span><span class=line><span class=cl>    <span class=m>1</span>     <span class=m>0</span> Ss   sleep <span class=m>1000</span>
</span></span><span class=line><span class=cl>root@9c0cd97e5da0:~# I<span class=err>&#39;</span>m child process, pid:31  ppid:0
</span></span></code></pre></div><p>由此可见，新版本的 docker engine 中正确处理了产生僵尸进程的问题。</p><h2 id=如何避免僵尸进程>如何避免僵尸进程<a hidden class=anchor aria-hidden=true href=#如何避免僵尸进程>#</a></h2><h3 id=直接-wait>直接 wait<a hidden class=anchor aria-hidden=true href=#直接-wait>#</a></h3><p>这是最简单的方法，父进程直接调用 wait/waitpid 函数等待子进程退出。这是最简单明了的展示如何使用 wait 给子进程收尸的例子。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;This is the child</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>   <span class=c1>//父进程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>stat_val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>waitpid</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stat_val</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>  <span class=cm>/*阻塞等待子进程*/</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>WIFEXITED</span><span class=p>(</span><span class=n>stat_val</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Child exited with code %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WEXITSTATUS</span><span class=p>(</span><span class=n>stat_val</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nf>WIFSIGNALED</span><span class=p>(</span><span class=n>stat_val</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Child terminated abnormally, signal %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WTERMSIG</span><span class=p>(</span><span class=n>stat_val</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>然而直接调用 wait 是阻塞的，父进程一直在等待直到 wait 返回，它才能做其他事。显然在实际开发中不能用这样的方法。</p><h3 id=通过信号机制>通过信号机制<a hidden class=anchor aria-hidden=true href=#通过信号机制>#</a></h3><p>子进程退出时会自动向父进程发送 SIGCHILD 信号，父进程先为 SIGCHILD信号注册处理函数。在信号处理函数中调用wait进行处理僵尸进程。</p><p>这样父进程就不用等待子进程退出，可以继续做自己的事。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_child</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//创建捕捉子进程退出信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>signal</span><span class=p>(</span><span class=n>SIGCHLD</span><span class=p>,</span><span class=n>sig_child</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;I am child process,pid id %d.I am exiting.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;I am father process.I will sleep two seconds</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//等待子进程先退出
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//输出进程信息
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>system</span><span class=p>(</span><span class=s>&#34;ps -o pid,ppid,state,tty,command&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;father process is exiting.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_child</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=kt>pid_t</span>      <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=kt>int</span>        <span class=n>stat</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=c1>//处理僵尸进程
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=k>while</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>waitpid</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stat</span><span class=p>,</span> <span class=n>WNOHANG</span><span class=p>))</span> <span class=o>&gt;</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child %d terminated.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=fork-两次>fork() 两次<a hidden class=anchor aria-hidden=true href=#fork-两次>#</a></h3><p>原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程处理僵尸进程。代码的逻辑结构大致如下:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span>  <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//创建第一个子进程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error:&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>       
</span></span><span class=line><span class=cl>        <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    	<span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;first procee is exited.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>//第二个子进程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>do_something</span><span class=p>();</span>    
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//父进程处理第一个子进程退出
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>waitpid</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>!=</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;waitepid error:&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><ul><li><a href=https://www.cnblogs.com/Anker/p/3271773.html>https://www.cnblogs.com/Anker/p/3271773.html</a></li><li><a href=https://yq.aliyun.com/articles/61894>https://yq.aliyun.com/articles/61894</a></li><li><a href=https://adoyle.me/blog/orphaned-process-and-zombie-process-and-docker.html>https://adoyle.me/blog/orphaned-process-and-zombie-process-and-docker.html</a></li><li><a href=https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/>https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/</a></li></ul><p>新旧 Docker 版本信息</p><pre tabindex=0><code>$docker version

新版本

Server: Docker Engine - Community
 Engine:
  Version:          18.09.6
  API version:      1.39 (minimum version 1.12)
  Go version:       go1.10.8
  Git commit:       481bc77
  Built:            Sat May  4 01:59:36 2019
  OS/Arch:          linux/amd64
  Experimental:     false

旧版本

Server:
 Engine:
  Version:          18.06.1-ce
  API version:      1.38 (minimum version 1.12)
  Go version:       go1.10.1
  Git commit:       e68fc7a
  Built:            Thu Jan 24 10:49:48 2019
  OS/Arch:          linux/amd64
  Experimental:     false
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://runzhen.github.io/tags/linux/>Linux</a></li><li><a href=https://runzhen.github.io/tags/docker/>Docker</a></li></ul><nav class=paginav><a class=prev href=https://runzhen.github.io/posts/address-space-layout-randomize/><span class=title>« Prev</span><br><span>ASLR 内核虚拟地址随机化</span>
</a><a class=next href=https://runzhen.github.io/posts/lsm-tree-basic/><span class=title>Next »</span><br><span>LSM Tree 简介</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Orphan, Zombie and Docker on x" href="https://x.com/intent/tweet/?text=Orphan%2c%20Zombie%20and%20Docker&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2forphan-zombie-and-docker%2f&amp;hashtags=linux%2cdocker"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Orphan, Zombie and Docker on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2forphan-zombie-and-docker%2f&amp;title=Orphan%2c%20Zombie%20and%20Docker&amp;summary=Orphan%2c%20Zombie%20and%20Docker&amp;source=https%3a%2f%2frunzhen.github.io%2fposts%2forphan-zombie-and-docker%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Orphan, Zombie and Docker on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frunzhen.github.io%2fposts%2forphan-zombie-and-docker%2f&title=Orphan%2c%20Zombie%20and%20Docker"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Orphan, Zombie and Docker on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frunzhen.github.io%2fposts%2forphan-zombie-and-docker%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Orphan, Zombie and Docker on whatsapp" href="https://api.whatsapp.com/send?text=Orphan%2c%20Zombie%20and%20Docker%20-%20https%3a%2f%2frunzhen.github.io%2fposts%2forphan-zombie-and-docker%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Orphan, Zombie and Docker on telegram" href="https://telegram.me/share/url?text=Orphan%2c%20Zombie%20and%20Docker&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2forphan-zombie-and-docker%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Orphan, Zombie and Docker on ycombinator" href="https://news.ycombinator.com/submitlink?t=Orphan%2c%20Zombie%20and%20Docker&u=https%3a%2f%2frunzhen.github.io%2fposts%2forphan-zombie-and-docker%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://runzhen.github.io/>Mind in the Wind</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>