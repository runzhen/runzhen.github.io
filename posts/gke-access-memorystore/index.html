<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>从 Kubernetes 中访问 Memorystore | Mind in the Wind</title>
<meta name=keywords content="gcp,k8s"><meta name=description content="Memorystore 是 Google Cloud 在 2018 年推出的托管 Redis 服务，让用户一键生成 Redis 实例，必要的时候再一键 scale，省去了维护 Redis 的烦恼。
本文在 k8s 中部署一个简单的小程序访问 Memorystore 数据库，获取 counter 值，并开启一个 http server 对外提供这个值。
准备
GCP 提供了一个命令行工具 gcloud，几乎所有的 web 操作都有对应的 CLI，非常方便。不同操作系统对应的安装包可以在这里下载
我的笔记本就叫它 “local host”，安装好 gcloud 之后，以下所有的操作都在 local 进行，命令执行的结果直接部署到 cloud 中。
现在开始前期准备工作。首先，在 GCP web 界面一键创建 Memorystore，之后我们能在 MemoryStore 的 Instances 里面看到这个实例，它的 IP 地址是 10.0.16.3 端口 6379。

很显然，10.0.16.3 这个 IP 是无法直接访问的，而如果你在相同的 GCP Project 里面创建了一个 VM instance，GCP 会自动创建一条路由，让你的 VM 可以 telnet 10.0.16.3 6379。
然后，创建一个 k8s 集群，这一步也同样可以在 web 界面里做，如果要用 GCP 提供的 gcloud 命令行的话如下："><meta name=author content="Me"><link rel=canonical href=https://runzhen.github.io/posts/gke-access-memorystore/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.103f87022495ee8537d399aa50bf7e2203f4c653b709467478c7fd5a58182364.css integrity="sha256-ED+HAiSV7oU305mqUL9+IgP0xlO3CUZ0eMf9WlgYI2Q=" rel="preload stylesheet" as=style><link rel=icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://runzhen.github.io/posts/gke-access-memorystore/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="从 Kubernetes 中访问 Memorystore"><meta property="og:description" content="Memorystore 是 Google Cloud 在 2018 年推出的托管 Redis 服务，让用户一键生成 Redis 实例，必要的时候再一键 scale，省去了维护 Redis 的烦恼。
本文在 k8s 中部署一个简单的小程序访问 Memorystore 数据库，获取 counter 值，并开启一个 http server 对外提供这个值。
准备
GCP 提供了一个命令行工具 gcloud，几乎所有的 web 操作都有对应的 CLI，非常方便。不同操作系统对应的安装包可以在这里下载
我的笔记本就叫它 “local host”，安装好 gcloud 之后，以下所有的操作都在 local 进行，命令执行的结果直接部署到 cloud 中。
现在开始前期准备工作。首先，在 GCP web 界面一键创建 Memorystore，之后我们能在 MemoryStore 的 Instances 里面看到这个实例，它的 IP 地址是 10.0.16.3 端口 6379。

很显然，10.0.16.3 这个 IP 是无法直接访问的，而如果你在相同的 GCP Project 里面创建了一个 VM instance，GCP 会自动创建一条路由，让你的 VM 可以 telnet 10.0.16.3 6379。
然后，创建一个 k8s 集群，这一步也同样可以在 web 界面里做，如果要用 GCP 提供的 gcloud 命令行的话如下："><meta property="og:type" content="article"><meta property="og:url" content="https://runzhen.github.io/posts/gke-access-memorystore/"><meta property="og:image" content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-25T14:49:42-07:00"><meta property="article:modified_time" content="2019-08-25T14:49:42-07:00"><meta property="og:site_name" content="Mind in the Wind"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="从 Kubernetes 中访问 Memorystore"><meta name=twitter:description content="Memorystore 是 Google Cloud 在 2018 年推出的托管 Redis 服务，让用户一键生成 Redis 实例，必要的时候再一键 scale，省去了维护 Redis 的烦恼。
本文在 k8s 中部署一个简单的小程序访问 Memorystore 数据库，获取 counter 值，并开启一个 http server 对外提供这个值。
准备
GCP 提供了一个命令行工具 gcloud，几乎所有的 web 操作都有对应的 CLI，非常方便。不同操作系统对应的安装包可以在这里下载
我的笔记本就叫它 “local host”，安装好 gcloud 之后，以下所有的操作都在 local 进行，命令执行的结果直接部署到 cloud 中。
现在开始前期准备工作。首先，在 GCP web 界面一键创建 Memorystore，之后我们能在 MemoryStore 的 Instances 里面看到这个实例，它的 IP 地址是 10.0.16.3 端口 6379。

很显然，10.0.16.3 这个 IP 是无法直接访问的，而如果你在相同的 GCP Project 里面创建了一个 VM instance，GCP 会自动创建一条路由，让你的 VM 可以 telnet 10.0.16.3 6379。
然后，创建一个 k8s 集群，这一步也同样可以在 web 界面里做，如果要用 GCP 提供的 gcloud 命令行的话如下："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://runzhen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"从 Kubernetes 中访问 Memorystore","item":"https://runzhen.github.io/posts/gke-access-memorystore/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"从 Kubernetes 中访问 Memorystore","name":"从 Kubernetes 中访问 Memorystore","description":"Memorystore 是 Google Cloud 在 2018 年推出的托管 Redis 服务，让用户一键生成 Redis 实例，必要的时候再一键 scale，省去了维护 Redis 的烦恼。\n本文在 k8s 中部署一个简单的小程序访问 Memorystore 数据库，获取 counter 值，并开启一个 http server 对外提供这个值。\n准备 GCP 提供了一个命令行工具 gcloud，几乎所有的 web 操作都有对应的 CLI，非常方便。不同操作系统对应的安装包可以在这里下载\n我的笔记本就叫它 “local host”，安装好 gcloud 之后，以下所有的操作都在 local 进行，命令执行的结果直接部署到 cloud 中。\n现在开始前期准备工作。首先，在 GCP web 界面一键创建 Memorystore，之后我们能在 MemoryStore 的 Instances 里面看到这个实例，它的 IP 地址是 10.0.16.3 端口 6379。\n很显然，10.0.16.3 这个 IP 是无法直接访问的，而如果你在相同的 GCP Project 里面创建了一个 VM instance，GCP 会自动创建一条路由，让你的 VM 可以 telnet 10.0.16.3 6379。\n然后，创建一个 k8s 集群，这一步也同样可以在 web 界面里做，如果要用 GCP 提供的 gcloud 命令行的话如下：\n","keywords":["gcp","k8s"],"articleBody":"Memorystore 是 Google Cloud 在 2018 年推出的托管 Redis 服务，让用户一键生成 Redis 实例，必要的时候再一键 scale，省去了维护 Redis 的烦恼。\n本文在 k8s 中部署一个简单的小程序访问 Memorystore 数据库，获取 counter 值，并开启一个 http server 对外提供这个值。\n准备 GCP 提供了一个命令行工具 gcloud，几乎所有的 web 操作都有对应的 CLI，非常方便。不同操作系统对应的安装包可以在这里下载\n我的笔记本就叫它 “local host”，安装好 gcloud 之后，以下所有的操作都在 local 进行，命令执行的结果直接部署到 cloud 中。\n现在开始前期准备工作。首先，在 GCP web 界面一键创建 Memorystore，之后我们能在 MemoryStore 的 Instances 里面看到这个实例，它的 IP 地址是 10.0.16.3 端口 6379。\n很显然，10.0.16.3 这个 IP 是无法直接访问的，而如果你在相同的 GCP Project 里面创建了一个 VM instance，GCP 会自动创建一条路由，让你的 VM 可以 telnet 10.0.16.3 6379。\n然后，创建一个 k8s 集群，这一步也同样可以在 web 界面里做，如果要用 GCP 提供的 gcloud 命令行的话如下：\ngcloud container clusters create visitcount-cluster --num-nodes=3 --enable-ip-alias 至此准备工作全部完成。\n一个 App 然后写一个小程序，读 Redis 的值返回给 http client，代码如下\npackage main import ( \"fmt\" \"log\" \"net/http\" \"os\" \"github.com/gomodule/redigo/redis\" ) var redisPool *redis.Pool func incrementHandler(w http.ResponseWriter, r *http.Request) { conn := redisPool.Get() defer conn.Close() counter, err := redis.Int(conn.Do(\"INCR\", \"visits\")) if err != nil { http.Error(w, \"Error incrementing visitor counter\", http.StatusInternalServerError) return } fmt.Fprintf(w, \"Visitor number: %d\", counter) } func main() { redisHost := os.Getenv(\"REDISHOST\") redisPort := os.Getenv(\"REDISPORT\") redisAddr := fmt.Sprintf(\"%s:%s\", redisHost, redisPort) const maxConnections = 10 redisPool = redis.NewPool(func() (redis.Conn, error) { return redis.Dial(\"tcp\", redisAddr) }, maxConnections) http.HandleFunc(\"/\", incrementHandler) log.Fatal(http.ListenAndServe(\":8080\", nil)) } 这段代码有以下几个功能：\n调用 redigo 库，这样几行代码就能操作 Redis 数据库，非常方便 开启了一个 http server，当外部 client 访问 http server 时，把 Redis 中取到的 counter 值返回给 client。 部署 app 到 kubernetes 我们知道，k8s 中运行的程序必须是容器化的，因此需要把上面这段代码生成二进制并打包成镜像。\n打包 docker image 的方式有很多种，可以本地编译成二进制以后再打包；也可以在build image 的时候编译程序。\n下面给出一个 Dockerfile，这是 google cloud 文档给出的一个示例。这个 image 在构建的过程中把程序源码也打包加入镜像了，我认为这样增加了 image 体积并不是很好。不过这是另外的话题了，不在本文讨论范围。\nFROM golang:1.8-alpine RUN apk update \u0026\u0026 apk add git RUN go get github.com/gomodule/redigo/redis ADD . /go/src/visit-counter RUN go install visit-counter ENV REDISHOST redis ENV REDISPORT 6379 ENTRYPOINT /go/bin/visit-counter EXPOSE 8080 有了这个 Dockerfile 以后，开始在本地 local host 打包 image\nexport PROJECT_ID=\"$(gcloud config get-value project -q)\" docker build -t gcr.io/${PROJECT_ID}/visit-counter:v1 . gcloud docker -- push gcr.io/${PROJECT_ID}/visit-counter:v1 注意: 生成的镜像是 gcr.io 加上你的 GCP 上这个 project 的 ID，因为最后要用 gcloud 命令把这个镜像 push 到 GCP “Container Register” 中去。\nk8s 部署 gcr.io 镜像 经过上面几步后，GCP “Container Register” 一栏中就会有这个 image 了，接下来就是通过 kubectl 命令让 kubernetes 自动去拉取镜像然后在集群中部署。\n在 local host 安装了 gcloud 工具后，可以通过 gcloud 安装 kubectl 插件，这样就可以在本地使用 kubectl 命令控制 cloud 中的 k8s 集群。\nk8s Deployment 先是 Deployment，然后再创建 Service。 因为我们 app 源码中获取 redis IP 是从环境变量读取的，因此在部署到 k8s 时也需要设置这个 ENV。\nexport REDISHOST_IP=10.0.16.3 kubectl create configmap redishost --from-literal=REDISHOST=${REDISHOST_IP} kubectl get configmaps redishost -o yaml 下面是正式的 Deployment 文件，除了基本的 kind，spec字段以外，还有 env 字段。\napiVersion: extensions/v1beta1 kind: Deployment metadata: name: visit-counter labels: app: visit-counter spec: replicas: 1 template: metadata: labels: app: visit-counter spec: containers: - name: visit-counter image: \"gcr.io//visit-counter:v1\" env: - name: REDISHOST valueFrom: configMapKeyRef: name: redishost key: REDISHOST ports: - name: http containerPort: 8080 最后一键部署 kubectl apply -f vc-deploy.yaml\nk8s Service deployment 的意思是让 k8s 运行这个容器，但是外界无法访问 http server 服务，因此还要让 k8s 提供 Service\napiVersion: v1 kind: Service metadata: name: visit-counter spec: type: LoadBalancer selector: app: visit-counter ports: - port: 80 targetPort: 8080 protocol: TCP 注意其中的 port/targetPort 字段，有必要解释一下。\nkubectl edit deploy visit-counter 可以看到更详细的 Deployment 信息。\nkubectl edit service visit-counter 有更详细的 Service 信息。\nports: - nodePort: 30553 port: 80 protocol: TCP targetPort: 8080 可以看到实际更加详细的还有 nodePort 。\nport 指 k8s 集群中服务之间可以互相访问的端口。 targetPort 指的 POD 上实际提供 service 的端口。 nodePort 指用户可以通过 kube-proxy 访问到的端口。 所以在回过头看上面的配置信息：\nport 80， 集群内部服务直接通过这个端口互相访问。 targetPort 8080，POD 上的端口。 nodePort 30553，kube-proxy 可以访问的端口。 稍等几分钟再执行 kubectl get service visit-counter\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.0.0.1 443/TCP 23h visit-counter LoadBalancer 10.0.15.95 35.xx.xxx.xx 80:30553/TCP 22h 从 EXTERNAL-IP 字段得知外界可访问的 IP，于是可以 curl http://EXTERNAL-IP\n上文刚刚提到，外部通过kube-proxy 可以访问的是 30553 端口，内部服务之间才能用 80 端口，可为什么这里直接访问 80 就行了呢？\n这是因为实际访问的是 LoadBalancer 的 80 端口。关于这一点，以及 kube-proxy 的作用，下一篇再讲。\n（完）\n参考资料\nhttps://cloud.google.com/memorystore/docs/redis/connect-redis-instance-gke ","wordCount":"528","inLanguage":"en","image":"https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2019-08-25T14:49:42-07:00","dateModified":"2019-08-25T14:49:42-07:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://runzhen.github.io/posts/gke-access-memorystore/"},"publisher":{"@type":"Organization","name":"Mind in the Wind","logo":{"@type":"ImageObject","url":"https://runzhen.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://runzhen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://runzhen.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://runzhen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://runzhen.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://runzhen.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://runzhen.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">从 Kubernetes 中访问 Memorystore</h1><div class=post-meta><span title='2019-08-25 14:49:42 -0700 PDT'>2019-08-25</span>&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%87%86%e5%a4%87 aria-label=准备>准备</a></li><li><a href=#%e4%b8%80%e4%b8%aa-app aria-label="一个 App">一个 App</a></li><li><a href=#%e9%83%a8%e7%bd%b2-app-%e5%88%b0-kubernetes aria-label="部署 app 到 kubernetes">部署 app 到 kubernetes</a></li><li><a href=#k8s-%e9%83%a8%e7%bd%b2-gcrio-%e9%95%9c%e5%83%8f aria-label="k8s 部署 gcr.io 镜像">k8s 部署 gcr.io 镜像</a><ul><li><a href=#k8s-deployment aria-label="k8s Deployment">k8s Deployment</a></li><li><a href=#k8s-service aria-label="k8s Service">k8s Service</a></li></ul></li></ul></div></details></div><div class=post-content><p>Memorystore 是 Google Cloud 在 2018 年推出的托管 Redis 服务，让用户一键生成 Redis 实例，必要的时候再一键 scale，省去了维护 Redis 的烦恼。</p><p>本文在 k8s 中部署一个简单的小程序访问 Memorystore 数据库，获取 counter 值，并开启一个 http server 对外提供这个值。</p><h2 id=准备>准备<a hidden class=anchor aria-hidden=true href=#准备>#</a></h2><p>GCP 提供了一个命令行工具 gcloud，几乎所有的 web 操作都有对应的 CLI，非常方便。不同操作系统对应的安装包可以在<a href=https://cloud.google.com/sdk/install>这里下载</a></p><p>我的笔记本就叫它 “local host”，安装好 gcloud 之后，以下所有的操作都在 local 进行，命令执行的结果直接部署到 cloud 中。</p><p>现在开始前期准备工作。首先，在 GCP web 界面一键创建 Memorystore，之后我们能在 MemoryStore 的 Instances 里面看到这个实例，它的 IP 地址是 10.0.16.3 端口 6379。</p><blockquote><p>很显然，10.0.16.3 这个 IP 是无法直接访问的，而如果你在相同的 GCP Project 里面创建了一个 VM instance，GCP 会自动创建一条路由，让你的 VM 可以 telnet 10.0.16.3 6379。</p></blockquote><p>然后，创建一个 k8s 集群，这一步也同样可以在 web 界面里做，如果要用 GCP 提供的 gcloud 命令行的话如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gcloud container clusters create visitcount-cluster --num-nodes<span class=o>=</span><span class=m>3</span> --enable-ip-alias
</span></span></code></pre></div><p>至此准备工作全部完成。</p><h2 id=一个-app>一个 App<a hidden class=anchor aria-hidden=true href=#一个-app>#</a></h2><p>然后写一个小程序，读 Redis 的值返回给 http client，代码如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;net/http&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;os&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;github.com/gomodule/redigo/redis&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>redisPool</span> <span class=o>*</span><span class=nx>redis</span><span class=p>.</span><span class=nx>Pool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>incrementHandler</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>conn</span> <span class=o>:=</span> <span class=nx>redisPool</span><span class=p>.</span><span class=nf>Get</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nx>counter</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>redis</span><span class=p>.</span><span class=nf>Int</span><span class=p>(</span><span class=nx>conn</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=s>&#34;INCR&#34;</span><span class=p>,</span> <span class=s>&#34;visits&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>http</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=s>&#34;Error incrementing visitor counter&#34;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                			<span class=nx>http</span><span class=p>.</span><span class=nx>StatusInternalServerError</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Fprintf</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=s>&#34;Visitor number: %d&#34;</span><span class=p>,</span> <span class=nx>counter</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>redisHost</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;REDISHOST&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>redisPort</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;REDISPORT&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>redisAddr</span> <span class=o>:=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%s:%s&#34;</span><span class=p>,</span> <span class=nx>redisHost</span><span class=p>,</span> <span class=nx>redisPort</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kd>const</span> <span class=nx>maxConnections</span> <span class=p>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>        <span class=nx>redisPool</span> <span class=p>=</span> <span class=nx>redis</span><span class=p>.</span><span class=nf>NewPool</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>(</span><span class=nx>redis</span><span class=p>.</span><span class=nx>Conn</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nx>redis</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=nx>redisAddr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span> <span class=nx>maxConnections</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nx>http</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/&#34;</span><span class=p>,</span> <span class=nx>incrementHandler</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;:8080&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这段代码有以下几个功能：</p><ul><li>调用 redigo 库，这样几行代码就能操作 Redis 数据库，非常方便</li><li>开启了一个 http server，当外部 client 访问 http server 时，把 Redis 中取到的 counter 值返回给 client。</li></ul><h2 id=部署-app-到-kubernetes>部署 app 到 kubernetes<a hidden class=anchor aria-hidden=true href=#部署-app-到-kubernetes>#</a></h2><p>我们知道，k8s 中运行的程序必须是容器化的，因此需要把上面这段代码生成二进制并打包成镜像。</p><p>打包 docker image 的方式有很多种，可以本地编译成二进制以后再打包；也可以在build image 的时候编译程序。</p><p>下面给出一个 Dockerfile，这是 google cloud 文档给出的一个示例。这个 image 在构建的过程中把程序源码也打包加入镜像了，我认为这样增加了 image 体积并不是很好。不过这是另外的话题了，不在本文讨论范围。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> golang:1.8-alpine</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apk update <span class=o>&amp;&amp;</span> apk add git<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> go get github.com/gomodule/redigo/redis<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ADD</span> . /go/src/visit-counter<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> go install visit-counter<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENV</span> REDISHOST redis<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENV</span> REDISPORT <span class=m>6379</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENTRYPOINT</span> /go/bin/visit-counter<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>EXPOSE</span><span class=s> 8080</span><span class=err>
</span></span></span></code></pre></div><p>有了这个 Dockerfile 以后，开始在本地 local host 打包 image</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> <span class=nv>PROJECT_ID</span><span class=o>=</span><span class=s2>&#34;</span><span class=k>$(</span>gcloud config get-value project -q<span class=k>)</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>docker build -t gcr.io/<span class=si>${</span><span class=nv>PROJECT_ID</span><span class=si>}</span>/visit-counter:v1 .
</span></span><span class=line><span class=cl>gcloud docker -- push gcr.io/<span class=si>${</span><span class=nv>PROJECT_ID</span><span class=si>}</span>/visit-counter:v1
</span></span></code></pre></div><p>注意: 生成的镜像是 gcr.io 加上你的 GCP 上这个 project 的 ID，因为最后要用 gcloud 命令把这个镜像 push 到 GCP “Container Register” 中去。</p><h2 id=k8s-部署-gcrio-镜像>k8s 部署 gcr.io 镜像<a hidden class=anchor aria-hidden=true href=#k8s-部署-gcrio-镜像>#</a></h2><p>经过上面几步后，GCP “Container Register” 一栏中就会有这个 image 了，接下来就是通过 kubectl 命令让 kubernetes 自动去拉取镜像然后在集群中部署。</p><p>在 local host 安装了 gcloud 工具后，可以通过 gcloud 安装 kubectl 插件，这样就可以在本地使用 kubectl 命令控制 cloud 中的 k8s 集群。</p><h3 id=k8s-deployment>k8s Deployment<a hidden class=anchor aria-hidden=true href=#k8s-deployment>#</a></h3><p>先是 Deployment，然后再创建 Service。 因为我们 app 源码中获取 redis IP 是从环境变量读取的，因此在部署到 k8s 时也需要设置这个 ENV。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> <span class=nv>REDISHOST_IP</span><span class=o>=</span>10.0.16.3
</span></span><span class=line><span class=cl>kubectl create configmap redishost --from-literal<span class=o>=</span><span class=nv>REDISHOST</span><span class=o>=</span><span class=si>${</span><span class=nv>REDISHOST_IP</span><span class=si>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>kubectl get configmaps redishost -o yaml
</span></span></code></pre></div><p>下面是正式的 Deployment 文件，除了基本的 kind，spec字段以外，还有 env 字段。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>extensions/v1beta1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>visit-counter</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>visit-counter</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>visit-counter</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>visit-counter</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;gcr.io/&lt;PROJECT_ID&gt;/visit-counter:v1&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>REDISHOST</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>valueFrom</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>configMapKeyRef</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redishost</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>key</span><span class=p>:</span><span class=w> </span><span class=l>REDISHOST</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>http</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span></code></pre></div><p>最后一键部署 <code>kubectl apply -f vc-deploy.yaml</code></p><h3 id=k8s-service>k8s Service<a hidden class=anchor aria-hidden=true href=#k8s-service>#</a></h3><p>deployment 的意思是让 k8s 运行这个容器，但是外界无法访问 http server 服务，因此还要让 k8s 提供 Service</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>visit-counter</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>LoadBalancer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>visit-counter</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>protocol</span><span class=p>:</span><span class=w> </span><span class=l>TCP</span><span class=w>
</span></span></span></code></pre></div><p>注意其中的 port/targetPort 字段，有必要解释一下。</p><p><code>kubectl edit deploy visit-counter</code> 可以看到更详细的 Deployment 信息。</p><p><code>kubectl edit service visit-counter</code> 有更详细的 Service 信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>nodePort</span><span class=p>:</span><span class=w> </span><span class=m>30553</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>protocol</span><span class=p>:</span><span class=w> </span><span class=l>TCP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span></code></pre></div><p>可以看到实际更加详细的还有 nodePort 。</p><ul><li><strong>port</strong> 指 k8s 集群中服务之间可以互相访问的端口。</li><li><strong>targetPort</strong> 指的 POD 上实际提供 service 的端口。</li><li><strong>nodePort</strong> 指用户可以通过 kube-proxy 访问到的端口。</li></ul><p>所以在回过头看上面的配置信息：</p><ol><li>port 80， 集群内部服务直接通过这个端口互相访问。</li><li>targetPort 8080，POD 上的端口。</li><li>nodePort 30553，kube-proxy 可以访问的端口。</li></ol><p>稍等几分钟再执行 <code>kubectl get service visit-counter</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>NAME            TYPE           CLUSTER-IP   EXTERNAL-IP     PORT<span class=o>(</span>S<span class=o>)</span>        AGE
</span></span><span class=line><span class=cl>kubernetes      ClusterIP      10.0.0.1     &lt;none&gt;          443/TCP        23h
</span></span><span class=line><span class=cl>visit-counter   LoadBalancer   10.0.15.95   35.xx.xxx.xx    80:30553/TCP   22h
</span></span></code></pre></div><p>从 EXTERNAL-IP 字段得知外界可访问的 IP，于是可以 <code>curl http://EXTERNAL-IP</code></p><p>上文刚刚提到，外部通过kube-proxy 可以访问的是 30553 端口，内部服务之间才能用 80 端口，可为什么这里直接访问 80 就行了呢？</p><p>这是因为实际访问的是 LoadBalancer 的 80 端口。关于这一点，以及 kube-proxy 的作用，下一篇再讲。</p><p>（完）</p><p>参考资料</p><ul><li><a href=https://cloud.google.com/memorystore/docs/redis/connect-redis-instance-gke>https://cloud.google.com/memorystore/docs/redis/connect-redis-instance-gke</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://runzhen.github.io/tags/gcp/>Gcp</a></li><li><a href=https://runzhen.github.io/tags/k8s/>K8s</a></li></ul><nav class=paginav><a class=prev href=https://runzhen.github.io/posts/taskset/><span class=title>« Prev</span><br><span>CPU affinity</span>
</a><a class=next href=https://runzhen.github.io/posts/build-your-vim8/><span class=title>Next »</span><br><span>Docker 中编译 vim8.0</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 从 Kubernetes 中访问 Memorystore on x" href="https://x.com/intent/tweet/?text=%e4%bb%8e%20Kubernetes%20%e4%b8%ad%e8%ae%bf%e9%97%ae%20Memorystore&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2fgke-access-memorystore%2f&amp;hashtags=gcp%2ck8s"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从 Kubernetes 中访问 Memorystore on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2fgke-access-memorystore%2f&amp;title=%e4%bb%8e%20Kubernetes%20%e4%b8%ad%e8%ae%bf%e9%97%ae%20Memorystore&amp;summary=%e4%bb%8e%20Kubernetes%20%e4%b8%ad%e8%ae%bf%e9%97%ae%20Memorystore&amp;source=https%3a%2f%2frunzhen.github.io%2fposts%2fgke-access-memorystore%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从 Kubernetes 中访问 Memorystore on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frunzhen.github.io%2fposts%2fgke-access-memorystore%2f&title=%e4%bb%8e%20Kubernetes%20%e4%b8%ad%e8%ae%bf%e9%97%ae%20Memorystore"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从 Kubernetes 中访问 Memorystore on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frunzhen.github.io%2fposts%2fgke-access-memorystore%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从 Kubernetes 中访问 Memorystore on whatsapp" href="https://api.whatsapp.com/send?text=%e4%bb%8e%20Kubernetes%20%e4%b8%ad%e8%ae%bf%e9%97%ae%20Memorystore%20-%20https%3a%2f%2frunzhen.github.io%2fposts%2fgke-access-memorystore%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从 Kubernetes 中访问 Memorystore on telegram" href="https://telegram.me/share/url?text=%e4%bb%8e%20Kubernetes%20%e4%b8%ad%e8%ae%bf%e9%97%ae%20Memorystore&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2fgke-access-memorystore%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从 Kubernetes 中访问 Memorystore on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e4%bb%8e%20Kubernetes%20%e4%b8%ad%e8%ae%bf%e9%97%ae%20Memorystore&u=https%3a%2f%2frunzhen.github.io%2fposts%2fgke-access-memorystore%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://runzhen.github.io/>Mind in the Wind</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>