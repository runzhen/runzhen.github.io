<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust 入坑之 LRU Cache | Mind in the Wind</title>
<meta name=keywords content="rust"><meta name=description content="lru 算法的原理简而言之就是一个 hash ，一个 double linked list
Linked List 提供 O(1) 的复杂度对元素进行插入和删除 hash 提供 O(1) 的复杂度进行查找 本文主要是通过阅读一个 rust 实现的 lru 学习相关语法。
如何在结构体里面使用指针？ rust 是否有 raw pointer 直接指向内存地址，如果能用该怎么用？ Linked List 节点结构体 上面提到，真正的 key/value 是存在双链表的 Node 里，所以需要先定义这个 Node 长什么样，lru-rs 中 LruEntry 表示的就是 node：
K V 代表的是泛型的类型， struct LruEntry<K, V> { key: mem::MaybeUninit<K>, val: mem::MaybeUninit<V>, prev: *mut LruEntry<K, V>, next: *mut LruEntry<K, V>, } 下面是如何初始化一个 Node，
impl<K, V> LruEntry<K, V> { fn new(key: K, val: V) -> Self { LruEntry { key: mem::MaybeUninit::new(key), val: mem::MaybeUninit::new(val), prev: ptr::null_mut(), next: ptr::null_mut(), } } fn new_sigil() -> Self { LruEntry { key: mem::MaybeUninit::uninit(), val: mem::MaybeUninit::uninit(), prev: ptr::null_mut(), next: ptr::null_mut(), } } } key value 用 mem::MaybeUninit::new(key)进行初始化 prev next 指针用 ptr::null_mut() 初始化 LRU cache 结构体 链表的 node 定义好以后，双链表结构也自然而然就有了。接下来还缺一个 map 结构体，这个可以用 rust 原生的 hash 函数库，然后就可以定义出 LRU 结构体"><meta name=author content="Me"><link rel=canonical href=https://runzhen.github.io/posts/rust-lru-cache/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.a8f620eb24ba9442cd3765590f9208a0752be50e5a7b9dd9e3e555c8cb5e74e6.css integrity="sha256-qPYg6yS6lELNN2VZD5IIoHUr5Q5ae53Z4+VVyMtedOY=" rel="preload stylesheet" as=style><link rel=icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://runzhen.github.io/posts/rust-lru-cache/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Rust 入坑之 LRU Cache"><meta property="og:description" content="lru 算法的原理简而言之就是一个 hash ，一个 double linked list
Linked List 提供 O(1) 的复杂度对元素进行插入和删除 hash 提供 O(1) 的复杂度进行查找 本文主要是通过阅读一个 rust 实现的 lru 学习相关语法。
如何在结构体里面使用指针？ rust 是否有 raw pointer 直接指向内存地址，如果能用该怎么用？ Linked List 节点结构体 上面提到，真正的 key/value 是存在双链表的 Node 里，所以需要先定义这个 Node 长什么样，lru-rs 中 LruEntry 表示的就是 node：
K V 代表的是泛型的类型， struct LruEntry<K, V> { key: mem::MaybeUninit<K>, val: mem::MaybeUninit<V>, prev: *mut LruEntry<K, V>, next: *mut LruEntry<K, V>, } 下面是如何初始化一个 Node，
impl<K, V> LruEntry<K, V> { fn new(key: K, val: V) -> Self { LruEntry { key: mem::MaybeUninit::new(key), val: mem::MaybeUninit::new(val), prev: ptr::null_mut(), next: ptr::null_mut(), } } fn new_sigil() -> Self { LruEntry { key: mem::MaybeUninit::uninit(), val: mem::MaybeUninit::uninit(), prev: ptr::null_mut(), next: ptr::null_mut(), } } } key value 用 mem::MaybeUninit::new(key)进行初始化 prev next 指针用 ptr::null_mut() 初始化 LRU cache 结构体 链表的 node 定义好以后，双链表结构也自然而然就有了。接下来还缺一个 map 结构体，这个可以用 rust 原生的 hash 函数库，然后就可以定义出 LRU 结构体"><meta property="og:type" content="article"><meta property="og:url" content="https://runzhen.github.io/posts/rust-lru-cache/"><meta property="og:image" content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-11T00:00:00+00:00"><meta property="article:modified_time" content="2021-07-11T00:00:00+00:00"><meta property="og:site_name" content="Mind in the Wind"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Rust 入坑之 LRU Cache"><meta name=twitter:description content="lru 算法的原理简而言之就是一个 hash ，一个 double linked list
Linked List 提供 O(1) 的复杂度对元素进行插入和删除 hash 提供 O(1) 的复杂度进行查找 本文主要是通过阅读一个 rust 实现的 lru 学习相关语法。
如何在结构体里面使用指针？ rust 是否有 raw pointer 直接指向内存地址，如果能用该怎么用？ Linked List 节点结构体 上面提到，真正的 key/value 是存在双链表的 Node 里，所以需要先定义这个 Node 长什么样，lru-rs 中 LruEntry 表示的就是 node：
K V 代表的是泛型的类型， struct LruEntry<K, V> { key: mem::MaybeUninit<K>, val: mem::MaybeUninit<V>, prev: *mut LruEntry<K, V>, next: *mut LruEntry<K, V>, } 下面是如何初始化一个 Node，
impl<K, V> LruEntry<K, V> { fn new(key: K, val: V) -> Self { LruEntry { key: mem::MaybeUninit::new(key), val: mem::MaybeUninit::new(val), prev: ptr::null_mut(), next: ptr::null_mut(), } } fn new_sigil() -> Self { LruEntry { key: mem::MaybeUninit::uninit(), val: mem::MaybeUninit::uninit(), prev: ptr::null_mut(), next: ptr::null_mut(), } } } key value 用 mem::MaybeUninit::new(key)进行初始化 prev next 指针用 ptr::null_mut() 初始化 LRU cache 结构体 链表的 node 定义好以后，双链表结构也自然而然就有了。接下来还缺一个 map 结构体，这个可以用 rust 原生的 hash 函数库，然后就可以定义出 LRU 结构体"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://runzhen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Rust 入坑之 LRU Cache","item":"https://runzhen.github.io/posts/rust-lru-cache/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust 入坑之 LRU Cache","name":"Rust 入坑之 LRU Cache","description":"lru 算法的原理简而言之就是一个 hash ，一个 double linked list\nLinked List 提供 O(1) 的复杂度对元素进行插入和删除 hash 提供 O(1) 的复杂度进行查找 本文主要是通过阅读一个 rust 实现的 lru 学习相关语法。\n如何在结构体里面使用指针？ rust 是否有 raw pointer 直接指向内存地址，如果能用该怎么用？ Linked List 节点结构体 上面提到，真正的 key/value 是存在双链表的 Node 里，所以需要先定义这个 Node 长什么样，lru-rs 中 LruEntry 表示的就是 node：\nK V 代表的是泛型的类型， struct LruEntry\u0026lt;K, V\u0026gt; { key: mem::MaybeUninit\u0026lt;K\u0026gt;, val: mem::MaybeUninit\u0026lt;V\u0026gt;, prev: *mut LruEntry\u0026lt;K, V\u0026gt;, next: *mut LruEntry\u0026lt;K, V\u0026gt;, } 下面是如何初始化一个 Node，\nimpl\u0026lt;K, V\u0026gt; LruEntry\u0026lt;K, V\u0026gt; { fn new(key: K, val: V) -\u0026gt; Self { LruEntry { key: mem::MaybeUninit::new(key), val: mem::MaybeUninit::new(val), prev: ptr::null_mut(), next: ptr::null_mut(), } } fn new_sigil() -\u0026gt; Self { LruEntry { key: mem::MaybeUninit::uninit(), val: mem::MaybeUninit::uninit(), prev: ptr::null_mut(), next: ptr::null_mut(), } } } key value 用 mem::MaybeUninit::new(key)进行初始化 prev next 指针用 ptr::null_mut() 初始化 LRU cache 结构体 链表的 node 定义好以后，双链表结构也自然而然就有了。接下来还缺一个 map 结构体，这个可以用 rust 原生的 hash 函数库，然后就可以定义出 LRU 结构体","keywords":["rust"],"articleBody":"lru 算法的原理简而言之就是一个 hash ，一个 double linked list\nLinked List 提供 O(1) 的复杂度对元素进行插入和删除 hash 提供 O(1) 的复杂度进行查找 本文主要是通过阅读一个 rust 实现的 lru 学习相关语法。\n如何在结构体里面使用指针？ rust 是否有 raw pointer 直接指向内存地址，如果能用该怎么用？ Linked List 节点结构体 上面提到，真正的 key/value 是存在双链表的 Node 里，所以需要先定义这个 Node 长什么样，lru-rs 中 LruEntry 表示的就是 node：\nK V 代表的是泛型的类型， struct LruEntry\u003cK, V\u003e { key: mem::MaybeUninit\u003cK\u003e, val: mem::MaybeUninit\u003cV\u003e, prev: *mut LruEntry\u003cK, V\u003e, next: *mut LruEntry\u003cK, V\u003e, } 下面是如何初始化一个 Node，\nimpl\u003cK, V\u003e LruEntry\u003cK, V\u003e { fn new(key: K, val: V) -\u003e Self { LruEntry { key: mem::MaybeUninit::new(key), val: mem::MaybeUninit::new(val), prev: ptr::null_mut(), next: ptr::null_mut(), } } fn new_sigil() -\u003e Self { LruEntry { key: mem::MaybeUninit::uninit(), val: mem::MaybeUninit::uninit(), prev: ptr::null_mut(), next: ptr::null_mut(), } } } key value 用 mem::MaybeUninit::new(key)进行初始化 prev next 指针用 ptr::null_mut() 初始化 LRU cache 结构体 链表的 node 定义好以后，双链表结构也自然而然就有了。接下来还缺一个 map 结构体，这个可以用 rust 原生的 hash 函数库，然后就可以定义出 LRU 结构体\npub struct LruCache\u003cK, V, S = DefaultHasher\u003e { map: HashMap\u003cKeyRef\u003cK\u003e, Box\u003cLruEntry\u003cK, V\u003e\u003e, S\u003e, cap: usize, // head and tail are sigil nodes to faciliate inserting entries head: *mut LruEntry\u003cK, V\u003e, tail: *mut LruEntry\u003cK, V\u003e, } head tail 指针和 Node 里面的指针用同样的定义方法。 map 用的是 rust 自带的 HashMap 结构，它需要输入一个 key 类型 K，一个 value 类型 V，和 hash 算法 S，不指明 S 的话会调用默认函数。 K 类型 是 KeyRef，这是自定义的类型，下面将会介绍 V 类型是用 Box 加上 LruEntry。Box是堆上分配的指针类型，称为“装箱”（boxed），其指针本身在栈，指向的数据在堆，见 参考资料1 新建一个 LRU Cache 的实现\npub fn new(cap: usize) -\u003e LruCache\u003cK, V\u003e { LruCache::construct(cap, HashMap::with_capacity(cap)) } fn construct(cap: usize, map: HashMap\u003cKeyRef\u003cK\u003e, Box\u003cLruEntry\u003cK, V\u003e\u003e, S\u003e) -\u003e LruCache\u003cK, V, S\u003e { let cache = LruCache { map, cap, head: Box::into_raw(Box::new(LruEntry::new_sigil())), tail: Box::into_raw(Box::new(LruEntry::new_sigil())), }; unsafe { (*cache.head).next = cache.tail; (*cache.tail).prev = cache.head; } cache } *const T和*mut T在 Rust 中被称为“裸指针” ，这里的星号不是解引用运算符，它是类型名称的一部分。 前者const 表示 “不可变”，不可变意味着指针解引用之后不能直接赋值，后者表示可以赋值。\nraw 指针可以绕过 Rust 的安全保障，但随之而来的是需要像 c++ 那样手动管理内存，rust 不再自动清除这块内存，不移动所有权，不管理生命周期。\n而且所有用到这个变量的地方都要加上 unsafe{} 字段，告诉编译器，程序员知道这段代码是 unsafe 的。\n一个简单的例子\nlet x = 5; let raw = \u0026x as *const i32; let points_at = unsafe { *raw }; println!(\"raw points at {}\", points_at); 再看 构造 LRU cache 的代码：\nhead tail 是原始的指针，因此在初始化时需要用 Box::into_raw函数获得 raw 指针 双链表首尾相连时，需要把代码放在 unsafe 块。 KeyRef 结构 pub struct KeyRef\u003cK\u003e { k: *const K, } impl\u003cK: Hash\u003e Hash for KeyRef\u003cK\u003e { fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) { unsafe { (*self.k).hash(state) } } } 注意这里 k 使用了 *const K类型的 raw pointer，因为这里不需要修改指向内存的值，而上面的 head tail 是需要修改双链表的前后关系的，所以需要 mut 关键字\nLRU cache 的 Put/Get 操作 put/get 是 LRU cache 最基本的操作，get 可以说是 put 的简化版，所以理解了 put 操作以后 get 自然而然就理解了。\nput 函数的流程如下：\n先查 hash map，如果有 key 就更新旧的 value，同时把 node 移到链表头，注意：因为 hash map里存的是指向 key 内存的指针，所以移动 node 的时候，hash map 的 key 指针仍然有效，因此不需要调整 hash map 如果没有，新建一个 node 并添加到链表头，如果容量已满，移除链表最后一个元素 hash map， key 为指向 node.key 的指针，value 为 node 指针，添加到 hash map 里 所以，理解 lru-rs put 函数的关键在于理解 rust code 是操作 raw pointer 的。\n具体关于 rust raw pointer 的解引用比我想象的要复杂的多，比如下面这段代码就包含了 3 次解引用，绕来绕去一不小心就会出错。\nlet old_key = KeyRef { k: unsafe { \u0026(*(*(*self.tail).prev).key.as_ptr()) }, }; 所以，初步使用体验下来，感觉 rust 的代码，设计指针操作的还是很麻烦的，甚至比 c/c++ 还要负杂。\nput/get 操作的具体实现就不一一解释了，直接看源码会更清楚 https://github.com/jeromefroe/lru-rs.git\n贴一个我实现的简化版本\nuse std::collections::HashMap; use core::ptr; struct Node { key: i32, value: i32, prev: *mut Node, next: *mut Node, } impl Node { fn new(key: i32, val: i32) -\u003e Self { Node { key, value: val, prev: ptr::null_mut(), next: ptr::null_mut(), } } fn new_null() -\u003e Self { Node { key: -1, value: -1, prev: ptr::null_mut(), next: ptr::null_mut(), } } } struct LRUCache { map: HashMap\u003ci32, Box\u003cNode\u003e\u003e, cap: i32, head: *mut Node, tail: *mut Node, } impl LRUCache { fn new(capacity: i32) -\u003e Self { let cache = LRUCache{ map: HashMap::new(), cap: capacity, head: Box::into_raw(Box::new(Node::new_null())), tail: Box::into_raw(Box::new(Node::new_null())), }; unsafe { (*cache.head).next = cache.tail; (*cache.tail).prev = cache.head; } cache } fn get(\u0026mut self, key: i32) -\u003e i32 { if let Some(v) = self.map.get_mut(\u0026key) { let node_ptr: *mut Node = \u0026mut **v; let value = (*(*v)).value; self.detach(node_ptr); self.push_front(node_ptr); return value } else { return -1 } } fn put(\u0026mut self, key: i32, value: i32) { let node_ptr = self.map.get_mut(\u0026key).map(|node| { let node_ptr : *mut Node = \u0026mut **node; node_ptr }); match node_ptr { Some(node_ptr) =\u003e { unsafe { (*node_ptr).value = value; } self.detach(node_ptr); self.push_front(node_ptr); } None =\u003e { if self.cap == 0 { return } let mut node: Box\u003cNode\u003e = Box::new(Node::new(key, value)); if self.len() == self.cap() { let oldest_key: i32; unsafe { oldest_key = (*(*(self.tail)).prev).key; }; let oldest_node: *mut Node = self.map.get_mut(\u0026oldest_key).map(|node| { let node_ptr : *mut Node = \u0026mut **node; node_ptr }).unwrap(); self.detach(oldest_node); // remove key from hash map self.map.remove(\u0026oldest_key).unwrap(); } let node_ptr: *mut Node = \u0026mut *node; self.push_front(node_ptr); self.map.insert(key, node); } } } fn len(\u0026self) -\u003e usize { self.map.len() } fn cap(\u0026self) -\u003e usize { self.cap as usize } fn push_front(\u0026mut self, n: *mut Node) { unsafe { (*n).next = (*self.head).next; (*n).prev = self.head; (*self.head).next = n; (*(*n).next).prev = n; } } fn detach(\u0026mut self, n: *mut Node) { unsafe { (*(*n).prev).next = (*n).next; (*(*n).next).prev = (*n).prev; } } fn print_all(\u0026self) { let mut head = self.head; let tail = self.tail; while head != tail { let cur: *mut Node; unsafe { cur = (*head).next; println!(\"key = {}, value = {}\", (*cur).key, (*cur).value); head = cur; } } } } fn main() { let mut lru = LRUCache::new(2); lru.put(1, 1); lru.put(2, 2); let v = lru.get(1); println!(\"key = {}, val = {}\", 1, v); lru.put(3, 3); let v = lru.get(2); println!(\"key = {}, val = {}\", 2, v); lru.put(4, 4); let v = lru.get(1); println!(\"key = {}, val = {}\", 1, v); let v = lru.get(3); println!(\"key = {}, val = {}\", 3, v); let v = lru.get(4); println!(\"key = {}, val = {}\", 4, v); } 参考资料 https://rustcc.cn/article?id=76e5f3fb-20b9-48c9-8fc6-a0aad40ced8c ","wordCount":"864","inLanguage":"en","image":"https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2021-07-11T00:00:00Z","dateModified":"2021-07-11T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://runzhen.github.io/posts/rust-lru-cache/"},"publisher":{"@type":"Organization","name":"Mind in the Wind","logo":{"@type":"ImageObject","url":"https://runzhen.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://runzhen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://runzhen.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://runzhen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://runzhen.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://runzhen.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://runzhen.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Rust 入坑之 LRU Cache</h1><div class=post-meta><span title='2021-07-11 00:00:00 +0000 UTC'>2021-07-11</span>&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#linked-list-%e8%8a%82%e7%82%b9%e7%bb%93%e6%9e%84%e4%bd%93 aria-label="Linked List 节点结构体">Linked List 节点结构体</a></li><li><a href=#lru-cache-%e7%bb%93%e6%9e%84%e4%bd%93 aria-label="LRU cache 结构体">LRU cache 结构体</a></li><li><a href=#keyref-%e7%bb%93%e6%9e%84 aria-label="KeyRef 结构">KeyRef 结构</a></li><li><a href=#lru-cache-%e7%9a%84-putget-%e6%93%8d%e4%bd%9c aria-label="LRU cache 的 Put/Get 操作">LRU cache 的 Put/Get 操作</a></li><li><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a></li></ul></div></details></div><div class=post-content><p>lru 算法的原理简而言之就是一个 hash ，一个 double linked list</p><ul><li>Linked List 提供 O(1) 的复杂度对元素进行插入和删除</li><li>hash 提供 O(1) 的复杂度进行查找</li></ul><p><img loading=lazy src=/image/2021/rust-lru/Untitled.png alt></p><p>本文主要是通过阅读一个 rust 实现的 lru 学习相关语法。</p><ul><li>如何在结构体里面使用指针？</li><li>rust 是否有 raw pointer 直接指向内存地址，如果能用该怎么用？</li></ul><h3 id=linked-list-节点结构体>Linked List 节点结构体<a hidden class=anchor aria-hidden=true href=#linked-list-节点结构体>#</a></h3><p>上面提到，真正的 <code>key/value</code> 是存在双链表的 Node 里，所以需要先定义这个 Node 长什么样，<code>lru-rs</code> 中 LruEntry 表示的就是 node：</p><ul><li>K V 代表的是泛型的类型，</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>struct</span> <span class=nx>LruEntry</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span> <span class=nx>V</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>key</span><span class=p>:</span> <span class=nx>mem</span><span class=p>::</span><span class=nx>MaybeUninit</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=nx>val</span><span class=p>:</span> <span class=nx>mem</span><span class=p>::</span><span class=nx>MaybeUninit</span><span class=p>&lt;</span><span class=nx>V</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=nx>prev</span><span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>LruEntry</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span> <span class=nx>V</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=nx>next</span><span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>LruEntry</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span> <span class=nx>V</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>下面是如何初始化一个 Node，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>impl</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span> <span class=nx>V</span><span class=p>&gt;</span> <span class=nx>LruEntry</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span> <span class=nx>V</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fn</span> <span class=nb>new</span><span class=p>(</span><span class=nx>key</span><span class=p>:</span> <span class=nx>K</span><span class=p>,</span> <span class=nx>val</span><span class=p>:</span> <span class=nx>V</span><span class=p>)</span> <span class=o>-</span><span class=p>&gt;</span> <span class=nx>Self</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>LruEntry</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>key</span><span class=p>:</span> <span class=nx>mem</span><span class=p>::</span><span class=nx>MaybeUninit</span><span class=p>::</span><span class=nb>new</span><span class=p>(</span><span class=nx>key</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=nx>val</span><span class=p>:</span> <span class=nx>mem</span><span class=p>::</span><span class=nx>MaybeUninit</span><span class=p>::</span><span class=nb>new</span><span class=p>(</span><span class=nx>val</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=nx>prev</span><span class=p>:</span> <span class=nx>ptr</span><span class=p>::</span><span class=nf>null_mut</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>            <span class=nx>next</span><span class=p>:</span> <span class=nx>ptr</span><span class=p>::</span><span class=nf>null_mut</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fn</span> <span class=nf>new_sigil</span><span class=p>()</span> <span class=o>-</span><span class=p>&gt;</span> <span class=nx>Self</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>LruEntry</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>key</span><span class=p>:</span> <span class=nx>mem</span><span class=p>::</span><span class=nx>MaybeUninit</span><span class=p>::</span><span class=nf>uninit</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>            <span class=nx>val</span><span class=p>:</span> <span class=nx>mem</span><span class=p>::</span><span class=nx>MaybeUninit</span><span class=p>::</span><span class=nf>uninit</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>            <span class=nx>prev</span><span class=p>:</span> <span class=nx>ptr</span><span class=p>::</span><span class=nf>null_mut</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>            <span class=nx>next</span><span class=p>:</span> <span class=nx>ptr</span><span class=p>::</span><span class=nf>null_mut</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>key value 用 <code>mem::MaybeUninit::new(key)</code>进行初始化</li><li>prev next 指针用 <code>ptr::null_mut()</code> 初始化</li></ul><h3 id=lru-cache-结构体>LRU cache 结构体<a hidden class=anchor aria-hidden=true href=#lru-cache-结构体>#</a></h3><p>链表的 node 定义好以后，双链表结构也自然而然就有了。接下来还缺一个 map 结构体，这个可以用 rust 原生的 hash 函数库，然后就可以定义出 LRU 结构体</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>pub</span> <span class=kd>struct</span> <span class=nx>LruCache</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span> <span class=nx>V</span><span class=p>,</span> <span class=nx>S</span> <span class=p>=</span> <span class=nx>DefaultHasher</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>map</span><span class=p>:</span> <span class=nx>HashMap</span><span class=p>&lt;</span><span class=nx>KeyRef</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>&gt;,</span> <span class=nx>Box</span><span class=p>&lt;</span><span class=nx>LruEntry</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span> <span class=nx>V</span><span class=o>&gt;&gt;</span><span class=p>,</span> <span class=nx>S</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=nx>cap</span><span class=p>:</span> <span class=nx>usize</span><span class=p>,</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// head and tail are sigil nodes to faciliate inserting entries
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>head</span><span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>LruEntry</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span> <span class=nx>V</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=nx>tail</span><span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>LruEntry</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span> <span class=nx>V</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>head tail 指针和 Node 里面的指针用同样的定义方法。</li><li>map 用的是 rust 自带的 HashMap 结构，它需要输入一个 key 类型 K，一个 value 类型 V，和 hash 算法 S，不指明 S 的话会调用默认函数。</li><li>K 类型 是 KeyRef，这是自定义的类型，下面将会介绍</li><li>V 类型是用 Box 加上 LruEntry。Box是堆上分配的指针类型，称为“装箱”（boxed），其指针本身在栈，指向的数据在堆，见 参考资料1</li></ul><p>新建一个 LRU Cache 的实现</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>pub</span> <span class=nx>fn</span> <span class=nb>new</span><span class=p>(</span><span class=nx>cap</span><span class=p>:</span> <span class=nx>usize</span><span class=p>)</span> <span class=o>-</span><span class=p>&gt;</span> <span class=nx>LruCache</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span> <span class=nx>V</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>LruCache</span><span class=p>::</span><span class=nf>construct</span><span class=p>(</span><span class=nx>cap</span><span class=p>,</span> <span class=nx>HashMap</span><span class=p>::</span><span class=nf>with_capacity</span><span class=p>(</span><span class=nx>cap</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>fn</span> <span class=nf>construct</span><span class=p>(</span><span class=nx>cap</span><span class=p>:</span> <span class=nx>usize</span><span class=p>,</span> <span class=kd>map</span><span class=p>:</span> <span class=nx>HashMap</span><span class=p>&lt;</span><span class=nx>KeyRef</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>&gt;,</span> <span class=nx>Box</span><span class=p>&lt;</span><span class=nx>LruEntry</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span> <span class=nx>V</span><span class=o>&gt;&gt;</span><span class=p>,</span> <span class=nx>S</span><span class=p>&gt;)</span> <span class=o>-</span><span class=p>&gt;</span> <span class=nx>LruCache</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span> <span class=nx>V</span><span class=p>,</span> <span class=nx>S</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>let</span> <span class=nx>cache</span> <span class=p>=</span> <span class=nx>LruCache</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>map</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>cap</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>head</span><span class=p>:</span> <span class=nx>Box</span><span class=p>::</span><span class=nf>into_raw</span><span class=p>(</span><span class=nx>Box</span><span class=p>::</span><span class=nb>new</span><span class=p>(</span><span class=nx>LruEntry</span><span class=p>::</span><span class=nf>new_sigil</span><span class=p>())),</span>
</span></span><span class=line><span class=cl>            <span class=nx>tail</span><span class=p>:</span> <span class=nx>Box</span><span class=p>::</span><span class=nf>into_raw</span><span class=p>(</span><span class=nx>Box</span><span class=p>::</span><span class=nb>new</span><span class=p>(</span><span class=nx>LruEntry</span><span class=p>::</span><span class=nf>new_sigil</span><span class=p>())),</span>
</span></span><span class=line><span class=cl>        <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nx>unsafe</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=o>*</span><span class=nx>cache</span><span class=p>.</span><span class=nx>head</span><span class=p>).</span><span class=nx>next</span> <span class=p>=</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=o>*</span><span class=nx>cache</span><span class=p>.</span><span class=nx>tail</span><span class=p>).</span><span class=nx>prev</span> <span class=p>=</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nx>cache</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p><code>*const T和*mut T在 Rust 中被称为“裸指针”</code> ，这里的星号不是解引用运算符，它是类型名称的一部分。 前者const 表示 “不可变”，不可变意味着指针解引用之后不能直接赋值，后者表示可以赋值。</p><p>raw 指针可以绕过 Rust 的安全保障，但随之而来的是需要像 c++ 那样手动管理内存，rust 不再自动清除这块内存，不移动所有权，不管理生命周期。</p><p>而且所有用到这个变量的地方都要加上 <code>unsafe{}</code> 字段，告诉编译器，程序员知道这段代码是 unsafe 的。</p><p>一个简单的例子</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>let</span> <span class=nx>x</span> <span class=p>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>let</span> <span class=nx>raw</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>x</span> <span class=nx>as</span> <span class=o>*</span><span class=kd>const</span> <span class=nx>i32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>let</span> <span class=nx>points_at</span> <span class=p>=</span> <span class=nx>unsafe</span> <span class=p>{</span> <span class=o>*</span><span class=nx>raw</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>println</span><span class=p>!(</span><span class=s>&#34;raw points at {}&#34;</span><span class=p>,</span> <span class=nx>points_at</span><span class=p>);</span>
</span></span></code></pre></div><p>再看 构造 LRU cache 的代码：</p><ul><li>head tail 是原始的指针，因此在初始化时需要用 <code>Box::into_raw</code>函数获得 raw 指针</li><li>双链表首尾相连时，需要把代码放在 <code>unsafe</code> 块。</li></ul><h3 id=keyref-结构>KeyRef 结构<a hidden class=anchor aria-hidden=true href=#keyref-结构>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>pub</span> <span class=kd>struct</span> <span class=nx>KeyRef</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>k</span><span class=p>:</span> <span class=o>*</span><span class=kd>const</span> <span class=nx>K</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>impl</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>:</span> <span class=nx>Hash</span><span class=p>&gt;</span> <span class=nx>Hash</span> <span class=k>for</span> <span class=nx>KeyRef</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fn</span> <span class=nx>hash</span><span class=p>&lt;</span><span class=nx>H</span><span class=p>:</span> <span class=nx>Hasher</span><span class=p>&gt;(</span><span class=o>&amp;</span><span class=nx>self</span><span class=p>,</span> <span class=nx>state</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>mut</span> <span class=nx>H</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>unsafe</span> <span class=p>{</span> <span class=p>(</span><span class=o>*</span><span class=nx>self</span><span class=p>.</span><span class=nx>k</span><span class=p>).</span><span class=nf>hash</span><span class=p>(</span><span class=nx>state</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注意这里 k 使用了 <code>*const K</code>类型的 raw pointer，因为这里不需要修改指向内存的值，而上面的 head tail 是需要修改双链表的前后关系的，所以需要 mut 关键字</p><h3 id=lru-cache-的-putget-操作>LRU cache 的 Put/Get 操作<a hidden class=anchor aria-hidden=true href=#lru-cache-的-putget-操作>#</a></h3><p>put/get 是 LRU cache 最基本的操作，get 可以说是 put 的简化版，所以理解了 put 操作以后 get 自然而然就理解了。</p><p>put 函数的流程如下：</p><ol><li>先查 hash map，如果有 key 就更新旧的 value，同时把 node 移到链表头，注意：<strong>因为 hash map里存的是指向 key 内存的指针，所以移动 node 的时候，hash map 的 key 指针仍然有效，因此不需要调整 hash map</strong></li><li>如果没有，新建一个 node 并添加到链表头，如果容量已满，移除链表最后一个元素</li><li>hash map， key 为指向 node.key 的指针，value 为 node 指针，添加到 hash map 里</li></ol><p><img loading=lazy src=/image/2021/rust-lru/Untitled%201.png alt></p><p>所以，理解 <code>lru-rs</code> put 函数的关键在于理解 rust code 是操作 raw pointer 的。</p><p>具体关于 rust raw pointer 的解引用比我想象的要复杂的多，比如下面这段代码就包含了 3 次解引用，绕来绕去一不小心就会出错。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>let</span> <span class=nx>old_key</span> <span class=p>=</span> <span class=nx>KeyRef</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>k</span><span class=p>:</span> <span class=nx>unsafe</span> <span class=p>{</span> <span class=o>&amp;</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>self</span><span class=p>.</span><span class=nx>tail</span><span class=p>).</span><span class=nx>prev</span><span class=p>).</span><span class=nx>key</span><span class=p>.</span><span class=nf>as_ptr</span><span class=p>())</span> <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>所以，初步使用体验下来，感觉 rust 的代码，设计指针操作的还是很麻烦的，甚至比 c/c++ 还要负杂。</p><p>put/get 操作的具体实现就不一一解释了，直接看源码会更清楚 <a href=https://github.com/jeromefroe/lru-rs.git>https://github.com/jeromefroe/lru-rs.git</a></p><p>贴一个我实现的简化版本</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>use</span> <span class=nx>std</span><span class=p>::</span><span class=nx>collections</span><span class=p>::</span><span class=nx>HashMap</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>use</span> <span class=nx>core</span><span class=p>::</span><span class=nx>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>struct</span> <span class=nx>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>key</span><span class=p>:</span> <span class=nx>i32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>value</span><span class=p>:</span> <span class=nx>i32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>prev</span><span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>Node</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>next</span><span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>Node</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>impl</span> <span class=nx>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fn</span> <span class=nb>new</span><span class=p>(</span><span class=nx>key</span><span class=p>:</span> <span class=nx>i32</span><span class=p>,</span> <span class=nx>val</span><span class=p>:</span> <span class=nx>i32</span><span class=p>)</span> <span class=o>-</span><span class=p>&gt;</span> <span class=nx>Self</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>key</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>value</span><span class=p>:</span> <span class=nx>val</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>prev</span><span class=p>:</span> <span class=nx>ptr</span><span class=p>::</span><span class=nf>null_mut</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>            <span class=nx>next</span><span class=p>:</span> <span class=nx>ptr</span><span class=p>::</span><span class=nf>null_mut</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fn</span> <span class=nf>new_null</span><span class=p>()</span> <span class=o>-</span><span class=p>&gt;</span> <span class=nx>Self</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>key</span><span class=p>:</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>value</span><span class=p>:</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>prev</span><span class=p>:</span> <span class=nx>ptr</span><span class=p>::</span><span class=nf>null_mut</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>            <span class=nx>next</span><span class=p>:</span> <span class=nx>ptr</span><span class=p>::</span><span class=nf>null_mut</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>struct</span> <span class=nx>LRUCache</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>map</span><span class=p>:</span> <span class=nx>HashMap</span><span class=p>&lt;</span><span class=nx>i32</span><span class=p>,</span> <span class=nx>Box</span><span class=p>&lt;</span><span class=nx>Node</span><span class=o>&gt;&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>cap</span><span class=p>:</span> <span class=nx>i32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>head</span><span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>Node</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>tail</span><span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>Node</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>impl</span> <span class=nx>LRUCache</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fn</span> <span class=nb>new</span><span class=p>(</span><span class=nx>capacity</span><span class=p>:</span> <span class=nx>i32</span><span class=p>)</span> <span class=o>-</span><span class=p>&gt;</span> <span class=nx>Self</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>let</span> <span class=nx>cache</span> <span class=p>=</span> <span class=nx>LRUCache</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>map</span><span class=p>:</span> <span class=nx>HashMap</span><span class=p>::</span><span class=nb>new</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>            <span class=nx>cap</span><span class=p>:</span> <span class=nx>capacity</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>head</span><span class=p>:</span> <span class=nx>Box</span><span class=p>::</span><span class=nf>into_raw</span><span class=p>(</span><span class=nx>Box</span><span class=p>::</span><span class=nb>new</span><span class=p>(</span><span class=nx>Node</span><span class=p>::</span><span class=nf>new_null</span><span class=p>())),</span>
</span></span><span class=line><span class=cl>            <span class=nx>tail</span><span class=p>:</span> <span class=nx>Box</span><span class=p>::</span><span class=nf>into_raw</span><span class=p>(</span><span class=nx>Box</span><span class=p>::</span><span class=nb>new</span><span class=p>(</span><span class=nx>Node</span><span class=p>::</span><span class=nf>new_null</span><span class=p>())),</span>
</span></span><span class=line><span class=cl>        <span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=nx>unsafe</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=o>*</span><span class=nx>cache</span><span class=p>.</span><span class=nx>head</span><span class=p>).</span><span class=nx>next</span> <span class=p>=</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=o>*</span><span class=nx>cache</span><span class=p>.</span><span class=nx>tail</span><span class=p>).</span><span class=nx>prev</span> <span class=p>=</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>cache</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fn</span> <span class=nf>get</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mut</span> <span class=nx>self</span><span class=p>,</span> <span class=nx>key</span><span class=p>:</span> <span class=nx>i32</span><span class=p>)</span> <span class=o>-</span><span class=p>&gt;</span> <span class=nx>i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>let</span> <span class=nf>Some</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span> <span class=p>=</span> <span class=nx>self</span><span class=p>.</span><span class=kd>map</span><span class=p>.</span><span class=nf>get_mut</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>let</span> <span class=nx>node_ptr</span><span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>Node</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>mut</span> <span class=o>**</span><span class=nx>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nx>let</span> <span class=nx>value</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>v</span><span class=p>)).</span><span class=nx>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=nx>self</span><span class=p>.</span><span class=nf>detach</span><span class=p>(</span><span class=nx>node_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nx>self</span><span class=p>.</span><span class=nf>push_front</span><span class=p>(</span><span class=nx>node_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>value</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fn</span> <span class=nf>put</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mut</span> <span class=nx>self</span><span class=p>,</span> <span class=nx>key</span><span class=p>:</span> <span class=nx>i32</span><span class=p>,</span> <span class=nx>value</span><span class=p>:</span> <span class=nx>i32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>let</span> <span class=nx>node_ptr</span> <span class=p>=</span> <span class=nx>self</span><span class=p>.</span><span class=kd>map</span><span class=p>.</span><span class=nf>get_mut</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>key</span><span class=p>).</span><span class=kd>map</span><span class=p>(|</span><span class=nx>node</span><span class=p>|</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>let</span> <span class=nx>node_ptr</span> <span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>Node</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>mut</span> <span class=o>**</span><span class=nx>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nx>node_ptr</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nx>match</span> <span class=nx>node_ptr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>Some</span><span class=p>(</span><span class=nx>node_ptr</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>unsafe</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=o>*</span><span class=nx>node_ptr</span><span class=p>).</span><span class=nx>value</span> <span class=p>=</span> <span class=nx>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=nx>self</span><span class=p>.</span><span class=nf>detach</span><span class=p>(</span><span class=nx>node_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nx>self</span><span class=p>.</span><span class=nf>push_front</span><span class=p>(</span><span class=nx>node_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>None</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=nx>self</span><span class=p>.</span><span class=nx>cap</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=nx>let</span> <span class=nx>mut</span> <span class=nx>node</span><span class=p>:</span> <span class=nx>Box</span><span class=p>&lt;</span><span class=nx>Node</span><span class=p>&gt;</span> <span class=p>=</span> <span class=nx>Box</span><span class=p>::</span><span class=nb>new</span><span class=p>(</span><span class=nx>Node</span><span class=p>::</span><span class=nb>new</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=nx>self</span><span class=p>.</span><span class=nb>len</span><span class=p>()</span> <span class=o>==</span> <span class=nx>self</span><span class=p>.</span><span class=nb>cap</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>let</span> <span class=nx>oldest_key</span><span class=p>:</span> <span class=nx>i32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=nx>unsafe</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=nx>oldest_key</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=nx>self</span><span class=p>.</span><span class=nx>tail</span><span class=p>)).</span><span class=nx>prev</span><span class=p>).</span><span class=nx>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                    <span class=nx>let</span> <span class=nx>oldest_node</span><span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>Node</span> <span class=p>=</span> <span class=nx>self</span><span class=p>.</span><span class=kd>map</span><span class=p>.</span><span class=nf>get_mut</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>oldest_key</span><span class=p>).</span><span class=kd>map</span><span class=p>(|</span><span class=nx>node</span><span class=p>|</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=nx>let</span> <span class=nx>node_ptr</span> <span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>Node</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>mut</span> <span class=o>**</span><span class=nx>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=nx>node_ptr</span>
</span></span><span class=line><span class=cl>                    <span class=p>}).</span><span class=nf>unwrap</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                    <span class=nx>self</span><span class=p>.</span><span class=nf>detach</span><span class=p>(</span><span class=nx>oldest_node</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                    <span class=c1>// remove key from hash map
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=nx>self</span><span class=p>.</span><span class=kd>map</span><span class=p>.</span><span class=nf>remove</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>oldest_key</span><span class=p>).</span><span class=nf>unwrap</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=nx>let</span> <span class=nx>node_ptr</span><span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>Node</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>mut</span> <span class=o>*</span><span class=nx>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=nx>self</span><span class=p>.</span><span class=nf>push_front</span><span class=p>(</span><span class=nx>node_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nx>self</span><span class=p>.</span><span class=kd>map</span><span class=p>.</span><span class=nf>insert</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>node</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fn</span> <span class=nb>len</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>self</span><span class=p>)</span> <span class=o>-</span><span class=p>&gt;</span> <span class=nx>usize</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>self</span><span class=p>.</span><span class=kd>map</span><span class=p>.</span><span class=nb>len</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fn</span> <span class=nb>cap</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>self</span><span class=p>)</span> <span class=o>-</span><span class=p>&gt;</span> <span class=nx>usize</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>self</span><span class=p>.</span><span class=nx>cap</span> <span class=nx>as</span> <span class=nx>usize</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fn</span> <span class=nf>push_front</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mut</span> <span class=nx>self</span><span class=p>,</span> <span class=nx>n</span><span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>Node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>unsafe</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=o>*</span><span class=nx>n</span><span class=p>).</span><span class=nx>next</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>self</span><span class=p>.</span><span class=nx>head</span><span class=p>).</span><span class=nx>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=o>*</span><span class=nx>n</span><span class=p>).</span><span class=nx>prev</span> <span class=p>=</span> <span class=nx>self</span><span class=p>.</span><span class=nx>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=o>*</span><span class=nx>self</span><span class=p>.</span><span class=nx>head</span><span class=p>).</span><span class=nx>next</span> <span class=p>=</span> <span class=nx>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>n</span><span class=p>).</span><span class=nx>next</span><span class=p>).</span><span class=nx>prev</span> <span class=p>=</span> <span class=nx>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fn</span> <span class=nf>detach</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mut</span> <span class=nx>self</span><span class=p>,</span> <span class=nx>n</span><span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>Node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>unsafe</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>n</span><span class=p>).</span><span class=nx>prev</span><span class=p>).</span><span class=nx>next</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>n</span><span class=p>).</span><span class=nx>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>n</span><span class=p>).</span><span class=nx>next</span><span class=p>).</span><span class=nx>prev</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>n</span><span class=p>).</span><span class=nx>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fn</span> <span class=nf>print_all</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>self</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>let</span> <span class=nx>mut</span> <span class=nx>head</span> <span class=p>=</span> <span class=nx>self</span><span class=p>.</span><span class=nx>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nx>let</span> <span class=nx>tail</span> <span class=p>=</span> <span class=nx>self</span><span class=p>.</span><span class=nx>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nx>while</span> <span class=nx>head</span> <span class=o>!=</span> <span class=nx>tail</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>let</span> <span class=nx>cur</span><span class=p>:</span> <span class=o>*</span><span class=nx>mut</span> <span class=nx>Node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nx>unsafe</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>cur</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>head</span><span class=p>).</span><span class=nx>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=nx>println</span><span class=p>!(</span><span class=s>&#34;key = {}, value = {}&#34;</span><span class=p>,</span> <span class=p>(</span><span class=o>*</span><span class=nx>cur</span><span class=p>).</span><span class=nx>key</span><span class=p>,</span> <span class=p>(</span><span class=o>*</span><span class=nx>cur</span><span class=p>).</span><span class=nx>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nx>head</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>fn</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>let</span> <span class=nx>mut</span> <span class=nx>lru</span> <span class=p>=</span> <span class=nx>LRUCache</span><span class=p>::</span><span class=nb>new</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>lru</span><span class=p>.</span><span class=nf>put</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>lru</span><span class=p>.</span><span class=nf>put</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>let</span> <span class=nx>v</span> <span class=p>=</span> <span class=nx>lru</span><span class=p>.</span><span class=nf>get</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>println</span><span class=p>!(</span><span class=s>&#34;key = {}, val = {}&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>lru</span><span class=p>.</span><span class=nf>put</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>let</span> <span class=nx>v</span> <span class=p>=</span> <span class=nx>lru</span><span class=p>.</span><span class=nf>get</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>println</span><span class=p>!(</span><span class=s>&#34;key = {}, val = {}&#34;</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=nx>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>lru</span><span class=p>.</span><span class=nf>put</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>let</span> <span class=nx>v</span> <span class=p>=</span> <span class=nx>lru</span><span class=p>.</span><span class=nf>get</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>println</span><span class=p>!(</span><span class=s>&#34;key = {}, val = {}&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>let</span> <span class=nx>v</span> <span class=p>=</span> <span class=nx>lru</span><span class=p>.</span><span class=nf>get</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>println</span><span class=p>!(</span><span class=s>&#34;key = {}, val = {}&#34;</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=nx>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>let</span> <span class=nx>v</span> <span class=p>=</span> <span class=nx>lru</span><span class=p>.</span><span class=nf>get</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>println</span><span class=p>!(</span><span class=s>&#34;key = {}, val = {}&#34;</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=nx>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h3><ol><li><a href="https://rustcc.cn/article?id=76e5f3fb-20b9-48c9-8fc6-a0aad40ced8c">https://rustcc.cn/article?id=76e5f3fb-20b9-48c9-8fc6-a0aad40ced8c</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://runzhen.github.io/tags/rust/>Rust</a></li></ul><nav class=paginav><a class=prev href=https://runzhen.github.io/posts/golang-pprof-usage/><span class=title>« Prev</span><br><span>Golang pprof 的使用姿势</span>
</a><a class=next href=https://runzhen.github.io/posts/bbolt/><span class=title>Next »</span><br><span>bbolt 的设计与实现</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Rust 入坑之 LRU Cache on x" href="https://x.com/intent/tweet/?text=Rust%20%e5%85%a5%e5%9d%91%e4%b9%8b%20LRU%20Cache&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2frust-lru-cache%2f&amp;hashtags=rust"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rust 入坑之 LRU Cache on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2frust-lru-cache%2f&amp;title=Rust%20%e5%85%a5%e5%9d%91%e4%b9%8b%20LRU%20Cache&amp;summary=Rust%20%e5%85%a5%e5%9d%91%e4%b9%8b%20LRU%20Cache&amp;source=https%3a%2f%2frunzhen.github.io%2fposts%2frust-lru-cache%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rust 入坑之 LRU Cache on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frunzhen.github.io%2fposts%2frust-lru-cache%2f&title=Rust%20%e5%85%a5%e5%9d%91%e4%b9%8b%20LRU%20Cache"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rust 入坑之 LRU Cache on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frunzhen.github.io%2fposts%2frust-lru-cache%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rust 入坑之 LRU Cache on whatsapp" href="https://api.whatsapp.com/send?text=Rust%20%e5%85%a5%e5%9d%91%e4%b9%8b%20LRU%20Cache%20-%20https%3a%2f%2frunzhen.github.io%2fposts%2frust-lru-cache%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rust 入坑之 LRU Cache on telegram" href="https://telegram.me/share/url?text=Rust%20%e5%85%a5%e5%9d%91%e4%b9%8b%20LRU%20Cache&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2frust-lru-cache%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rust 入坑之 LRU Cache on ycombinator" href="https://news.ycombinator.com/submitlink?t=Rust%20%e5%85%a5%e5%9d%91%e4%b9%8b%20LRU%20Cache&u=https%3a%2f%2frunzhen.github.io%2fposts%2frust-lru-cache%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://runzhen.github.io/>Mind in the Wind</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>