<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang reflect 的使用 | Mind in the Wind</title>
<meta name=keywords content="golang"><meta name=description content='所谓反射 (refection) 是指程序在运行过程中获取变量的类型、属性。 在 Golang 中，有时我们会看到 reflect.ValueOf() 或者 reflect.TypeOf() 这两个函数，这就是反射出一个变量的值和类型。 gPRC 的实现中也大量运用了反射。
本文主要介绍如何使用 reflect 包，关于 Go 内部是如何实现的将在下一篇文章中介绍。
TypeOf 和 ValueOf
先看一个最简单的例子
type User struct {
	Name string
	Age  int
}

func main() {
	u := User{"Dick", 18}

	t := reflect.TypeOf(u)
	v := reflect.ValueOf(u)

	fmt.Printf("u type = %T, %v\n", u, u)
	fmt.Printf("t type = %T, %v\n", t, t)
	fmt.Printf("v type = %T, %v\n", v, v)

	// 获取 v 的值
	// v.Age , 错误，因为 v 是 reflect.Value 类型

	// 正确方式如下
	v1 := v.Interface().(User)
}
以上代码运行结果如下：
u type = main.User, {Dick 18}
t type = *reflect.rtype, main.User
v type = reflect.Value, {Dick 18}
可以看出，使用 reflect.ValueOf 返回的是一个 reflect.Value 类型，需要先通过 Interface() 函数返回成一个 interface 类型，再做强制类型转换。'><meta name=author content="Me"><link rel=canonical href=https://runzhen.github.io/posts/golang-reflect/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.103f87022495ee8537d399aa50bf7e2203f4c653b709467478c7fd5a58182364.css integrity="sha256-ED+HAiSV7oU305mqUL9+IgP0xlO3CUZ0eMf9WlgYI2Q=" rel="preload stylesheet" as=style><link rel=icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://runzhen.github.io/posts/golang-reflect/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Golang reflect 的使用"><meta property="og:description" content='所谓反射 (refection) 是指程序在运行过程中获取变量的类型、属性。 在 Golang 中，有时我们会看到 reflect.ValueOf() 或者 reflect.TypeOf() 这两个函数，这就是反射出一个变量的值和类型。 gPRC 的实现中也大量运用了反射。
本文主要介绍如何使用 reflect 包，关于 Go 内部是如何实现的将在下一篇文章中介绍。
TypeOf 和 ValueOf
先看一个最简单的例子
type User struct {
	Name string
	Age  int
}

func main() {
	u := User{"Dick", 18}

	t := reflect.TypeOf(u)
	v := reflect.ValueOf(u)

	fmt.Printf("u type = %T, %v\n", u, u)
	fmt.Printf("t type = %T, %v\n", t, t)
	fmt.Printf("v type = %T, %v\n", v, v)

	// 获取 v 的值
	// v.Age , 错误，因为 v 是 reflect.Value 类型

	// 正确方式如下
	v1 := v.Interface().(User)
}
以上代码运行结果如下：
u type = main.User, {Dick 18}
t type = *reflect.rtype, main.User
v type = reflect.Value, {Dick 18}
可以看出，使用 reflect.ValueOf 返回的是一个 reflect.Value 类型，需要先通过 Interface() 函数返回成一个 interface 类型，再做强制类型转换。'><meta property="og:type" content="article"><meta property="og:url" content="https://runzhen.github.io/posts/golang-reflect/"><meta property="og:image" content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-03T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-03T00:00:00+00:00"><meta property="og:site_name" content="Mind in the Wind"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Golang reflect 的使用"><meta name=twitter:description content='所谓反射 (refection) 是指程序在运行过程中获取变量的类型、属性。 在 Golang 中，有时我们会看到 reflect.ValueOf() 或者 reflect.TypeOf() 这两个函数，这就是反射出一个变量的值和类型。 gPRC 的实现中也大量运用了反射。
本文主要介绍如何使用 reflect 包，关于 Go 内部是如何实现的将在下一篇文章中介绍。
TypeOf 和 ValueOf
先看一个最简单的例子
type User struct {
	Name string
	Age  int
}

func main() {
	u := User{"Dick", 18}

	t := reflect.TypeOf(u)
	v := reflect.ValueOf(u)

	fmt.Printf("u type = %T, %v\n", u, u)
	fmt.Printf("t type = %T, %v\n", t, t)
	fmt.Printf("v type = %T, %v\n", v, v)

	// 获取 v 的值
	// v.Age , 错误，因为 v 是 reflect.Value 类型

	// 正确方式如下
	v1 := v.Interface().(User)
}
以上代码运行结果如下：
u type = main.User, {Dick 18}
t type = *reflect.rtype, main.User
v type = reflect.Value, {Dick 18}
可以看出，使用 reflect.ValueOf 返回的是一个 reflect.Value 类型，需要先通过 Interface() 函数返回成一个 interface 类型，再做强制类型转换。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://runzhen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Golang reflect 的使用","item":"https://runzhen.github.io/posts/golang-reflect/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang reflect 的使用","name":"Golang reflect 的使用","description":"所谓反射 (refection) 是指程序在运行过程中获取变量的类型、属性。 在 Golang 中，有时我们会看到 reflect.ValueOf() 或者 reflect.TypeOf() 这两个函数，这就是反射出一个变量的值和类型。 gPRC 的实现中也大量运用了反射。\n本文主要介绍如何使用 reflect 包，关于 Go 内部是如何实现的将在下一篇文章中介绍。\nTypeOf 和 ValueOf 先看一个最简单的例子\ntype User struct { Name string Age int } func main() { u := User{\u0026#34;Dick\u0026#34;, 18} t := reflect.TypeOf(u) v := reflect.ValueOf(u) fmt.Printf(\u0026#34;u type = %T, %v\\n\u0026#34;, u, u) fmt.Printf(\u0026#34;t type = %T, %v\\n\u0026#34;, t, t) fmt.Printf(\u0026#34;v type = %T, %v\\n\u0026#34;, v, v) // 获取 v 的值 // v.Age , 错误，因为 v 是 reflect.Value 类型 // 正确方式如下 v1 := v.Interface().(User) } 以上代码运行结果如下：\nu type = main.User, {Dick 18} t type = *reflect.rtype, main.User v type = reflect.Value, {Dick 18} 可以看出，使用 reflect.ValueOf 返回的是一个 reflect.Value 类型，需要先通过 Interface() 函数返回成一个 interface 类型，再做强制类型转换。\n","keywords":["golang"],"articleBody":"所谓反射 (refection) 是指程序在运行过程中获取变量的类型、属性。 在 Golang 中，有时我们会看到 reflect.ValueOf() 或者 reflect.TypeOf() 这两个函数，这就是反射出一个变量的值和类型。 gPRC 的实现中也大量运用了反射。\n本文主要介绍如何使用 reflect 包，关于 Go 内部是如何实现的将在下一篇文章中介绍。\nTypeOf 和 ValueOf 先看一个最简单的例子\ntype User struct { Name string Age int } func main() { u := User{\"Dick\", 18} t := reflect.TypeOf(u) v := reflect.ValueOf(u) fmt.Printf(\"u type = %T, %v\\n\", u, u) fmt.Printf(\"t type = %T, %v\\n\", t, t) fmt.Printf(\"v type = %T, %v\\n\", v, v) // 获取 v 的值 // v.Age , 错误，因为 v 是 reflect.Value 类型 // 正确方式如下 v1 := v.Interface().(User) } 以上代码运行结果如下：\nu type = main.User, {Dick 18} t type = *reflect.rtype, main.User v type = reflect.Value, {Dick 18} 可以看出，使用 reflect.ValueOf 返回的是一个 reflect.Value 类型，需要先通过 Interface() 函数返回成一个 interface 类型，再做强制类型转换。\n同样道理，reflect.TypeOf 返回的是一个 reflect.rtype 类型，这个类型的值才是 User 结构体。\nreflect.Value 还提供了 v.Type() 函数返回对应的 reflect.rtype\n遍历结构体字段 当我们不知道一个结构体对象的是什么类型，有哪些成员函数的时候，可以使用 type.NumField() 和 type.NumMethod() 获取它的成员和函数。\n例如下面这个例子\ntype User struct { Name string Age int Addr string } func (u User) Foobar() { fmt.Println(\"Foobar\") } func (u *User) Barfoo() { fmt.Println(\"Barfoo\") } func reflectUnknownStruct(input interface{}) { t := reflect.TypeOf(input) v := reflect.ValueOf(input) for i := 0; i \u003c t.NumField(); i++ { field := t.Field(i) value := v.Field(i).Interface() fmt.Printf(\"%s: %v = %v\\n\", field.Name, field.Type, value) } for i := 0; i \u003c t.NumMethod(); i++ { m := t.Method(i) fmt.Printf(\"%s: %v\\n\", m.Name, m.Type) } } func main() { u := User{\"Dick\", 18, \"earth\"} reflectUnknownStruct(u) 输出结果\nName: string = Dick Age: int = 18 Addr: string = earth Foobar: func(main.User) 值得注意的是，其中 func (u *User) Barfoo() 并没有被反射出来，因为它是 *User 类型的方法。\n那么该如何反射出 Barfoo() 呢？ 目前还不知道，相信研究 reflect 的实现以后会发现答案。\n通过 reflect.Value 设置变量的值 借用第一小节的例子，\ntype User struct { Name string Age int } func main() { u := User{\"Dick\", 18} // 注意，参数必须是指针才能修改其值 pointer := reflect.ValueOf(\u0026u) // 使用 Elem() 获得指针指向的 Value newValue := pointer.Elem() fmt.Println(\"type of pointer:\", newValue.Type()) fmt.Println(\"CanSet() :\", newValue.CanSet()) newValue.FieldByName(\"Age\").SetInt(28) fmt.Println(\"new value of u:\", u) } Go 语言的函数调用都是传值的，所以我们得到的反射对象跟最开始的变量没有任何关系，直接修改反射对象无法改变原始变量。\n要设置 Value 的值，前提要传入变量的指针，这样 ValueOf() 函数返回的 Value 所对应的类型是 reflect.Ptr (reflect 包内置定义了全部的基础类型，用户可以通过 Kind() 函数获取，这部分将在 reflect 包的实现中在解释 )\n之后使用 Elem() 函数通过指针获得真正的 Value，此时获得 Value 代表的是 User 结构体，要想修改 Age，需要用 FieldByName 找到对应的 field。\n通过 reflect.Value 调用结构体方法 type User struct { Name string Age int } func (u User) Rename(name string, age int) { fmt.Println(\"name = \", name, \", age = \", age, \", original User.Name = \", u.Name) } func main() { user := User{\"Dick\", 18} getValue := reflect.ValueOf(user) methodValue := getValue.MethodByName(\"Rename\") // 指定参数 args := []reflect.Value{reflect.ValueOf(\"Wood\"), reflect.ValueOf(30)} methodValue.Call(args) } 基本的逻辑还是一样的，需要注意的是传递参数需要用 []reflect.Value{} 。\n如果函数没有参数，创建一个长度为 0 的make([]reflect.Value, 0) 既可。\n实际用途 说了这些 reflect 的用法后，那么日常开发过程中有哪些地方要用到 reflect 呢？ 其中之一就是序列化/反序列化，类似 json Marshall 函数那样。\n下面就用一个例子展示一些如何自己实现一个序列化函数。\npackage main import ( \"fmt\" \"reflect\" \"strconv\" ) type Person struct { Name string `info:\"name\"` Age int `info:\"age\"` unexported string `info:\"unexported\"` NoTag string } func UnMarshall(d interface{}, m map[string]string) { typ := reflect.TypeOf(d) // 首先判断传入参数的类型 if !(typ.Kind() == reflect.Ptr \u0026\u0026 typ.Elem().Kind() == reflect.Struct) { fmt.Printf(\"Should pass ptr to destination struct object.\\n\") return } typ = typ.Elem() value := reflect.ValueOf(d).Elem() // 遍历每一个字段 for i := 0; i \u003c typ.NumField(); i++ { field := typ.Field(i) // https://stackoverflow.com/questions/68573907/ // how-to-get-only-data-exported-fields-from-protobuf-struct-with-reflect if !field.IsExported() { fmt.Printf(\"`%s` is not exported, skip\\n\", field.Name) continue } // 判断是否设置了这个tag mytag := field.Tag.Get(\"info\") if mytag == \"\" { fmt.Printf(\"tag `info` not exist in field: %s, ignore ...\\n\", field.Name) continue } // check if input data has value v := m[mytag] if v == \"\" { fmt.Printf(\"tag vaule is not found in the input data, ignore\\n\") continue } // 根据类型来设置值 switch fieldType := field.Type.Kind(); fieldType { case reflect.Int, reflect.Int16, reflect.Int32, reflect.Int64: typedV, _ := strconv.ParseInt(v, 10, 64) value.Field(i).SetInt(typedV) case reflect.String: value.Field(i).SetString(v) case reflect.Uint, reflect.Uint16, reflect.Uint32, reflect.Uint64: typedV, _ := strconv.ParseUint(v, 10, 64) value.Field(i).SetUint(typedV) case reflect.Bool: value.Field(i).SetBool(v == \"true\") default: fmt.Printf(\"field type %s not support yet\\n\", fieldType) } } } func main() { p := Person{} d := map[string]string{ \"name\": \"John\", \"age\": \"16\", \"unexported\": \"hello\", } UnMarshall(\u0026p, d) fmt.Printf(\"%+v\", p) } 参考资料 https://juejin.cn/post/6844903559335526407 https://github.com/a8m/reflect-examples https://jiajunhuang.com/articles/2022_01_10-reflect_binding_args.md.html ","wordCount":"606","inLanguage":"en","image":"https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2021-04-03T00:00:00Z","dateModified":"2021-04-03T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://runzhen.github.io/posts/golang-reflect/"},"publisher":{"@type":"Organization","name":"Mind in the Wind","logo":{"@type":"ImageObject","url":"https://runzhen.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://runzhen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://runzhen.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://runzhen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://runzhen.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://runzhen.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://runzhen.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Golang reflect 的使用</h1><div class=post-meta><span title='2021-04-03 00:00:00 +0000 UTC'>2021-04-03</span>&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#typeof-%e5%92%8c-valueof aria-label="TypeOf 和 ValueOf">TypeOf 和 ValueOf</a></li><li><a href=#%e9%81%8d%e5%8e%86%e7%bb%93%e6%9e%84%e4%bd%93%e5%ad%97%e6%ae%b5 aria-label=遍历结构体字段>遍历结构体字段</a></li><li><a href=#%e9%80%9a%e8%bf%87-reflectvalue-%e8%ae%be%e7%bd%ae%e5%8f%98%e9%87%8f%e7%9a%84%e5%80%bc aria-label="通过 reflect.Value 设置变量的值">通过 reflect.Value 设置变量的值</a></li><li><a href=#%e9%80%9a%e8%bf%87-reflectvalue-%e8%b0%83%e7%94%a8%e7%bb%93%e6%9e%84%e4%bd%93%e6%96%b9%e6%b3%95 aria-label="通过 reflect.Value 调用结构体方法">通过 reflect.Value 调用结构体方法</a></li><li><a href=#%e5%ae%9e%e9%99%85%e7%94%a8%e9%80%94 aria-label=实际用途>实际用途</a></li><li><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a></li></ul></div></details></div><div class=post-content><p>所谓反射 (refection) 是指程序在运行过程中获取变量的类型、属性。 在 Golang 中，有时我们会看到 <code>reflect.ValueOf()</code> 或者 <code>reflect.TypeOf()</code> 这两个函数，这就是反射出一个变量的值和类型。 gPRC 的实现中也大量运用了反射。</p><p>本文主要介绍如何使用 reflect 包，关于 Go 内部是如何实现的将在下一篇文章中介绍。</p><h2 id=typeof-和-valueof>TypeOf 和 ValueOf<a hidden class=anchor aria-hidden=true href=#typeof-和-valueof>#</a></h2><p>先看一个最简单的例子</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>User</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Name</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>Age</span>  <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>u</span> <span class=o>:=</span> <span class=nx>User</span><span class=p>{</span><span class=s>&#34;Dick&#34;</span><span class=p>,</span> <span class=mi>18</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>t</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>TypeOf</span><span class=p>(</span><span class=nx>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>v</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>ValueOf</span><span class=p>(</span><span class=nx>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;u type = %T, %v\n&#34;</span><span class=p>,</span> <span class=nx>u</span><span class=p>,</span> <span class=nx>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;t type = %T, %v\n&#34;</span><span class=p>,</span> <span class=nx>t</span><span class=p>,</span> <span class=nx>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;v type = %T, %v\n&#34;</span><span class=p>,</span> <span class=nx>v</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 获取 v 的值</span>
</span></span><span class=line><span class=cl>	<span class=c1>// v.Age , 错误，因为 v 是 reflect.Value 类型</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 正确方式如下</span>
</span></span><span class=line><span class=cl>	<span class=nx>v1</span> <span class=o>:=</span> <span class=nx>v</span><span class=p>.</span><span class=nf>Interface</span><span class=p>().(</span><span class=nx>User</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>以上代码运行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>u <span class=nb>type</span> <span class=o>=</span> main.User, <span class=o>{</span>Dick 18<span class=o>}</span>
</span></span><span class=line><span class=cl>t <span class=nb>type</span> <span class=o>=</span> *reflect.rtype, main.User
</span></span><span class=line><span class=cl>v <span class=nb>type</span> <span class=o>=</span> reflect.Value, <span class=o>{</span>Dick 18<span class=o>}</span>
</span></span></code></pre></div><p>可以看出，使用 reflect.ValueOf 返回的是一个 reflect.Value 类型，需要先通过 Interface() 函数返回成一个 interface 类型，再做强制类型转换。</p><p>同样道理，reflect.TypeOf 返回的是一个 reflect.rtype 类型，这个类型的值才是 User 结构体。</p><p>reflect.Value 还提供了 v.Type() 函数返回对应的 reflect.rtype</p><h2 id=遍历结构体字段>遍历结构体字段<a hidden class=anchor aria-hidden=true href=#遍历结构体字段>#</a></h2><p>当我们不知道一个结构体对象的是什么类型，有哪些成员函数的时候，可以使用 <code>type.NumField()</code> 和 <code>type.NumMethod()</code> 获取它的成员和函数。</p><p>例如下面这个例子</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>User</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Name</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>Age</span>  <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>Addr</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>u</span> <span class=nx>User</span><span class=p>)</span> <span class=nf>Foobar</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Foobar&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>u</span> <span class=o>*</span><span class=nx>User</span><span class=p>)</span> <span class=nf>Barfoo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Barfoo&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>reflectUnknownStruct</span><span class=p>(</span><span class=nx>input</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>t</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>TypeOf</span><span class=p>(</span><span class=nx>input</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>v</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>ValueOf</span><span class=p>(</span><span class=nx>input</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>t</span><span class=p>.</span><span class=nf>NumField</span><span class=p>();</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>field</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>value</span> <span class=o>:=</span> <span class=nx>v</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nf>Interface</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s: %v = %v\n&#34;</span><span class=p>,</span> <span class=nx>field</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span> <span class=nx>field</span><span class=p>.</span><span class=nx>Type</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>t</span><span class=p>.</span><span class=nf>NumMethod</span><span class=p>();</span> <span class=nx>i</span><span class=o>++</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>m</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nf>Method</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s: %v\n&#34;</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Type</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>u</span> <span class=o>:=</span> <span class=nx>User</span><span class=p>{</span><span class=s>&#34;Dick&#34;</span><span class=p>,</span> <span class=mi>18</span><span class=p>,</span> <span class=s>&#34;earth&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>reflectUnknownStruct</span><span class=p>(</span><span class=nx>u</span><span class=p>)</span>
</span></span></code></pre></div><p>输出结果</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Name: <span class=nv>string</span> <span class=o>=</span> Dick
</span></span><span class=line><span class=cl>Age: <span class=nv>int</span> <span class=o>=</span> <span class=m>18</span>
</span></span><span class=line><span class=cl>Addr: <span class=nv>string</span> <span class=o>=</span> earth
</span></span><span class=line><span class=cl>Foobar: func<span class=o>(</span>main.User<span class=o>)</span>
</span></span></code></pre></div><blockquote><p>值得注意的是，其中 <code>func (u *User) Barfoo()</code> 并没有被反射出来，因为它是 <code>*User</code> 类型的方法。</p></blockquote><p>那么该如何反射出 <code>Barfoo()</code> 呢？ 目前还不知道，相信研究 reflect 的实现以后会发现答案。</p><h2 id=通过-reflectvalue-设置变量的值>通过 reflect.Value 设置变量的值<a hidden class=anchor aria-hidden=true href=#通过-reflectvalue-设置变量的值>#</a></h2><p>借用第一小节的例子，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>User</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Name</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>Age</span>  <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>u</span> <span class=o>:=</span> <span class=nx>User</span><span class=p>{</span><span class=s>&#34;Dick&#34;</span><span class=p>,</span> <span class=mi>18</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 注意，参数必须是指针才能修改其值</span>
</span></span><span class=line><span class=cl>	<span class=nx>pointer</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>ValueOf</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1>// 使用 Elem() 获得指针指向的 Value</span>
</span></span><span class=line><span class=cl>	<span class=nx>newValue</span> <span class=o>:=</span> <span class=nx>pointer</span><span class=p>.</span><span class=nf>Elem</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;type of pointer:&#34;</span><span class=p>,</span> <span class=nx>newValue</span><span class=p>.</span><span class=nf>Type</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;CanSet() :&#34;</span><span class=p>,</span> <span class=nx>newValue</span><span class=p>.</span><span class=nf>CanSet</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=nx>newValue</span><span class=p>.</span><span class=nf>FieldByName</span><span class=p>(</span><span class=s>&#34;Age&#34;</span><span class=p>).</span><span class=nf>SetInt</span><span class=p>(</span><span class=mi>28</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;new value of u:&#34;</span><span class=p>,</span> <span class=nx>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Go 语言的函数调用都是传值的</strong>，所以我们得到的反射对象跟最开始的变量没有任何关系，直接修改反射对象无法改变原始变量。</p><p>要设置 Value 的值，前提要传入变量的指针，这样 ValueOf() 函数返回的 Value 所对应的类型是 reflect.Ptr (reflect 包内置定义了全部的基础类型，用户可以通过 Kind() 函数获取，这部分将在 reflect 包的实现中在解释 )</p><p>之后使用 Elem() 函数通过指针获得真正的 Value，此时获得 Value 代表的是 User 结构体，要想修改 Age，需要用 FieldByName 找到对应的 field。</p><h2 id=通过-reflectvalue-调用结构体方法>通过 reflect.Value 调用结构体方法<a hidden class=anchor aria-hidden=true href=#通过-reflectvalue-调用结构体方法>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>User</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Name</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>Age</span>  <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>u</span> <span class=nx>User</span><span class=p>)</span> <span class=nf>Rename</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>age</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;name = &#34;</span><span class=p>,</span> <span class=nx>name</span><span class=p>,</span> <span class=s>&#34;, age = &#34;</span><span class=p>,</span> <span class=nx>age</span><span class=p>,</span> <span class=s>&#34;, original User.Name = &#34;</span><span class=p>,</span> <span class=nx>u</span><span class=p>.</span><span class=nx>Name</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>user</span> <span class=o>:=</span> <span class=nx>User</span><span class=p>{</span><span class=s>&#34;Dick&#34;</span><span class=p>,</span> <span class=mi>18</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>getValue</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>ValueOf</span><span class=p>(</span><span class=nx>user</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>methodValue</span> <span class=o>:=</span> <span class=nx>getValue</span><span class=p>.</span><span class=nf>MethodByName</span><span class=p>(</span><span class=s>&#34;Rename&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 指定参数</span>
</span></span><span class=line><span class=cl>	<span class=nx>args</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>reflect</span><span class=p>.</span><span class=nx>Value</span><span class=p>{</span><span class=nx>reflect</span><span class=p>.</span><span class=nf>ValueOf</span><span class=p>(</span><span class=s>&#34;Wood&#34;</span><span class=p>),</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>ValueOf</span><span class=p>(</span><span class=mi>30</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>	<span class=nx>methodValue</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span><span class=nx>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>基本的逻辑还是一样的，需要注意的是传递参数需要用 <code>[]reflect.Value{}</code> 。</p><p>如果函数没有参数，创建一个长度为 0 的<code>make([]reflect.Value, 0)</code> 既可。</p><h2 id=实际用途>实际用途<a hidden class=anchor aria-hidden=true href=#实际用途>#</a></h2><p>说了这些 reflect 的用法后，那么日常开发过程中有哪些地方要用到 reflect 呢？ 其中之一就是序列化/反序列化，类似 json Marshall 函数那样。</p><p>下面就用一个例子展示一些如何自己实现一个序列化函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;reflect&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;strconv&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Person</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Name</span>       <span class=kt>string</span> <span class=s>`info:&#34;name&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=nx>Age</span>        <span class=kt>int</span>    <span class=s>`info:&#34;age&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=nx>unexported</span> <span class=kt>string</span> <span class=s>`info:&#34;unexported&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=nx>NoTag</span>      <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>UnMarshall</span><span class=p>(</span><span class=nx>d</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>m</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>typ</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>TypeOf</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 首先判断传入参数的类型</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!(</span><span class=nx>typ</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()</span> <span class=o>==</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Ptr</span> <span class=o>&amp;&amp;</span> <span class=nx>typ</span><span class=p>.</span><span class=nf>Elem</span><span class=p>().</span><span class=nf>Kind</span><span class=p>()</span> <span class=o>==</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Struct</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Should pass ptr to destination struct object.\n&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>typ</span> <span class=p>=</span> <span class=nx>typ</span><span class=p>.</span><span class=nf>Elem</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>value</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>ValueOf</span><span class=p>(</span><span class=nx>d</span><span class=p>).</span><span class=nf>Elem</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 遍历每一个字段</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>typ</span><span class=p>.</span><span class=nf>NumField</span><span class=p>();</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>field</span> <span class=o>:=</span> <span class=nx>typ</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// https://stackoverflow.com/questions/68573907/</span>
</span></span><span class=line><span class=cl>		<span class=c1>// how-to-get-only-data-exported-fields-from-protobuf-struct-with-reflect</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nx>field</span><span class=p>.</span><span class=nf>IsExported</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;`%s` is not exported, skip\n&#34;</span><span class=p>,</span> <span class=nx>field</span><span class=p>.</span><span class=nx>Name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// 判断是否设置了这个tag</span>
</span></span><span class=line><span class=cl>		<span class=nx>mytag</span> <span class=o>:=</span> <span class=nx>field</span><span class=p>.</span><span class=nx>Tag</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;info&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>mytag</span> <span class=o>==</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;tag `info` not exist in field: %s, ignore ...\n&#34;</span><span class=p>,</span> <span class=nx>field</span><span class=p>.</span><span class=nx>Name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// check if input data has value</span>
</span></span><span class=line><span class=cl>		<span class=nx>v</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>[</span><span class=nx>mytag</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>v</span> <span class=o>==</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;tag vaule is not found in the input data, ignore\n&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// 根据类型来设置值</span>
</span></span><span class=line><span class=cl>		<span class=k>switch</span> <span class=nx>fieldType</span> <span class=o>:=</span> <span class=nx>field</span><span class=p>.</span><span class=nx>Type</span><span class=p>.</span><span class=nf>Kind</span><span class=p>();</span> <span class=nx>fieldType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Int</span><span class=p>,</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Int16</span><span class=p>,</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Int32</span><span class=p>,</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Int64</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>typedV</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>ParseInt</span><span class=p>(</span><span class=nx>v</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>value</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nf>SetInt</span><span class=p>(</span><span class=nx>typedV</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>String</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>value</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nf>SetString</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Uint</span><span class=p>,</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Uint16</span><span class=p>,</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Uint32</span><span class=p>,</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Uint64</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>typedV</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>ParseUint</span><span class=p>(</span><span class=nx>v</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>value</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nf>SetUint</span><span class=p>(</span><span class=nx>typedV</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>value</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nf>SetBool</span><span class=p>(</span><span class=nx>v</span> <span class=o>==</span> <span class=s>&#34;true&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;field type %s not support yet\n&#34;</span><span class=p>,</span> <span class=nx>fieldType</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span> <span class=o>:=</span> <span class=nx>Person</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>d</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;name&#34;</span><span class=p>:</span>       <span class=s>&#34;John&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;age&#34;</span><span class=p>:</span>        <span class=s>&#34;16&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;unexported&#34;</span><span class=p>:</span> <span class=s>&#34;hello&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>UnMarshall</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>p</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%+v&#34;</span><span class=p>,</span> <span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><ul><li><a href=https://juejin.cn/post/6844903559335526407>https://juejin.cn/post/6844903559335526407</a></li><li><a href=https://github.com/a8m/reflect-examples>https://github.com/a8m/reflect-examples</a></li><li><a href=https://jiajunhuang.com/articles/2022_01_10-reflect_binding_args.md.html>https://jiajunhuang.com/articles/2022_01_10-reflect_binding_args.md.html</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://runzhen.github.io/tags/golang/>Golang</a></li></ul><nav class=paginav><a class=prev href=https://runzhen.github.io/posts/golang-waitgroup/><span class=title>« Prev</span><br><span>Golang WaitGroup 的实现</span>
</a><a class=next href=https://runzhen.github.io/posts/golang-io-package/><span class=title>Next »</span><br><span>Golang io 包的实现</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang reflect 的使用 on x" href="https://x.com/intent/tweet/?text=Golang%20reflect%20%e7%9a%84%e4%bd%bf%e7%94%a8&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2fgolang-reflect%2f&amp;hashtags=golang"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang reflect 的使用 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2fgolang-reflect%2f&amp;title=Golang%20reflect%20%e7%9a%84%e4%bd%bf%e7%94%a8&amp;summary=Golang%20reflect%20%e7%9a%84%e4%bd%bf%e7%94%a8&amp;source=https%3a%2f%2frunzhen.github.io%2fposts%2fgolang-reflect%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang reflect 的使用 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frunzhen.github.io%2fposts%2fgolang-reflect%2f&title=Golang%20reflect%20%e7%9a%84%e4%bd%bf%e7%94%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang reflect 的使用 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frunzhen.github.io%2fposts%2fgolang-reflect%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang reflect 的使用 on whatsapp" href="https://api.whatsapp.com/send?text=Golang%20reflect%20%e7%9a%84%e4%bd%bf%e7%94%a8%20-%20https%3a%2f%2frunzhen.github.io%2fposts%2fgolang-reflect%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang reflect 的使用 on telegram" href="https://telegram.me/share/url?text=Golang%20reflect%20%e7%9a%84%e4%bd%bf%e7%94%a8&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2fgolang-reflect%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang reflect 的使用 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Golang%20reflect%20%e7%9a%84%e4%bd%bf%e7%94%a8&u=https%3a%2f%2frunzhen.github.io%2fposts%2fgolang-reflect%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://runzhen.github.io/>Mind in the Wind</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>