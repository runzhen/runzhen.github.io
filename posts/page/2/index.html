<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Blog | Mind in the Wind</title>
<meta name=keywords content><meta name=description content="Blog - Mind in the Wind"><meta name=author content="Me"><link rel=canonical href=https://runzhen.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.103f87022495ee8537d399aa50bf7e2203f4c653b709467478c7fd5a58182364.css integrity="sha256-ED+HAiSV7oU305mqUL9+IgP0xlO3CUZ0eMf9WlgYI2Q=" rel="preload stylesheet" as=style><link rel=icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://runzhen.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://runzhen.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Blog"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://runzhen.github.io/posts/"><meta property="og:image" content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="Mind in the Wind"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Blog"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://runzhen.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://runzhen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://runzhen.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://runzhen.github.io/posts/ title=Blog><span class=active>Blog</span></a></li><li><a href=https://runzhen.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://runzhen.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://runzhen.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Blog
<a href=/posts/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Union Find 并查集</h2></header><div class=entry-content><p>本文几乎全部摘抄了这篇文章，因为写的已经足够清晰易懂了，没有必要自己再做改动。
唯一区别是代码改成了用 Golang 实现。
基础概念 并查集有两个英文名：Disjoint Set, Union Find它的作用就是把一个数据集分成若干个子集，每个子集内部数据可以互联互通，而子集之间则不具有连通性。
并查集的底层结构类似于堆，也是用数组描述一种树结构，但不同的是，堆是一棵独立的二叉树，并查集的树是多叉树，而且可能不止一棵树(也就是森林)。在并查集中，我们把相互独立的数据集称为连通分量，连通分量在逻辑上可以形象地描述为一棵树，每棵树都有一个根节点，其他的元素都会直接或间接指向根节点。
比如下图这个并查集，我们维护一个parent数组，每个元素初始化为对应的数组下标，代表自己是独立的一棵树，且是树根。以第一棵树为例，在后续数据处理过程中，我们把与所有与"2"同属一个连通分量的元素都连到"2"上，并把数组对应下标的元素赋值为2，其中"5"先连接到了"1"上，“1"又连接到了"2"上。最后，数组每个元素都代表其指向的父节点。
知道了并查集的底层结构，那我们该如何去构建这个结构并进行查找操作呢？并查集有两个最重要的方法：union 和 find，这里先给出 UnionFind 最完善的 API 框架伪代码：
UnionFind { Init(int N) {} // 构造方法 Find(int x) int {} //查找某个元素的根节点 Union(int x, int y) {} // 为x和y建立联系 IsConnected(int x, int y) bool {} //判断x和y是否相连(在同一棵树也就是连通分量中) Count() int {} // 返回连通分量的个数，也就是多少棵树 } find 方法实现 find方法的目的是寻找某个元素所在树的根节点，代码如下：
// 查找根节点 func (uf *UnionFind) Find (x int) int { for { if x == uf.parent[x] { break } x = uf....</p></div><footer class=entry-footer><span title='2022-08-02 00:00:00 +0000 UTC'>2022-08-02</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Union Find 并查集" href=https://runzhen.github.io/posts/union-find/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Dijkstra 和 Floyd 最短路径算法</h2></header><div class=entry-content><p>图的表示 邻接矩阵（Adjacency Matrix） 邻接矩阵是图的常用存储表示，它的底层依赖一个二维数组。它用两个数组分别存储数据元素（顶点）的信息和数据元素之间的关系（边或弧）的信息。
优点：
邻接矩阵的存储方式简单、直接，可以高效的获取两个顶点的关系； 计算方便。（求解最短路径 Floyd-Warshall 算法） 用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。
邻接表（Adjacency List） Dijkstra 算法 算法的基本逻辑这篇视频里讲的很清楚，简单来说有以下两个步骤
每次从未标记的节点中选择与出发点最近的点，标记。 计算第一步刚加入的节点 A 的邻近节点 B 的距离。如果节点A 到出发点的距离 + A 到 B 的距离 &lt; 节点 B 的当前值，则更新 B 的距离。 下面看一下算法的大体思路，完整代码见 https://leetcode.com/problems/network-delay-time
// 邻接表表示法. 并且没有用指针把节点串起来， // 直接用 map[NodeId]Distance 表示了 graph := make([]map[int]int, n+1) // digkstra distance := make([]int, n+1) visited := make([]bool, n+1) // 先赋值无穷大 for i, _ := range distance { distance[i] = math.MaxInt64 } distance[k] = 0 for { // 在没有 visited 的节点中，找 distance 最小的 nextNode := findNextNode(visited, distance) if nextNode == -1 { break } // 标记为已访问 visited[nextNode] = true // 更新这个节点的相邻节点到 K 的最小距离 for k, v := range graph[nextNode] { if distance[k] > v + distance[nextNode] { distance[k] = v + distance[nextNode] } } } 可以看出，算法的复杂度与节点的个数相关，假设有 N 个节点，则 O(n^2)...</p></div><footer class=entry-footer><span title='2022-07-31 00:00:00 +0000 UTC'>2022-07-31</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Dijkstra 和 Floyd 最短路径算法" href=https://runzhen.github.io/posts/graph-dijkstra-floyd/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 中 for range 和 slice 的坑</h2></header><div class=entry-content><p>for range 的实现 下面这段代码会永无止境的循环吗 ？
package main import ( "fmt" ) func main() { sl := []int{1,2,3,4} for _, v := range sl{ sl = append(sl, v) } fmt.Println(sl) } 要验证它很简单，运行一下即可得到结果，最后的结果是
[1 2 3 4 1 2 3 4] 要理解为什么会有这样的结果不难，首先我们需要清楚一点 go 语言中的赋值语句都是赋值，那么就意味着
如果赋值的是一个指针, 那么拷贝的是指针指向对象的地址(就是一个数值, 至于这个数值有多大, 具体要看运行的平台)也就是指针的值 如果赋值的是一个对象, 那么就会拷贝这个对象 然后，我们再来看一下，当 for range 遇到不同的迭代对象时，编译器是如何展开代码的
数组 range_temp := range len_temp := len(range) for index_temp = 0; index_temp &lt; len_temp; index_temp++ { value_temp = range_temp[index_temp] index = index_temp value = value_temp original body } slice 切片 for_temp := range len_temp := len(for_temp) for index_temp = 0; index_temp &lt; len_temp; index_temp++ { value_temp = for_temp[index_temp] index = index_temp value = value_temp original body } map // Lower a for range over a map....</p></div><footer class=entry-footer><span title='2022-07-29 00:00:00 +0000 UTC'>2022-07-29</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Go 中 for range 和 slice 的坑" href=https://runzhen.github.io/posts/go-for-range-and-slice/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Heap 和 Priority Queue</h2></header><div class=entry-content><p>什么是堆 堆是一棵具有特定性质的二叉树。
堆首先必须是一棵完全二叉树； 这棵完全二叉树中，任意一个结点的值都大于等于它的左右孩子结点的值，这样的堆称为大顶堆（也叫最大堆，Max-Heap）；或者任意一个结点的值都小于等于它的左右孩子结点的值，这样的堆称为小顶堆（也叫最小堆，Min-Heap） 因为它是完全二叉树，所以通常在写代码的时候，我们会用一个数组表示树的元素，而且会把第 0 号空出来，这样：
假设 parent index 为 i，左节点 idx = i * 2，右节点 idx = i * 2 + 1 。 假设某个节点 index = i，其父节点 idx = i / 2 。 什么是优先队列 Priority Queue 是一种数据结构，普通的 Queue 是先进先出，而 PQ 能根据每个元素包含的优先级，选择下一个出队的元素。堆 （Heap）通常是实现 PQ 的底层数据结构，但并不意味着 PQ 一定是堆。
通常有以下应用
数据压缩：赫夫曼编码算法； 最短路径算法：Dijkstra算法； 最小生成树算法：Prim算法； 事件驱动仿真：顾客排队算法； 选择问题：查找第k个最小元素； Golang Heap Go 的 container/heap包提供了一个接口，
type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1....</p></div><footer class=entry-footer><span title='2022-07-17 00:00:00 +0000 UTC'>2022-07-17</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Heap 和 Priority Queue" href=https://runzhen.github.io/posts/heap-and-priority-queue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>一致性哈希 Consistent Hashing</h2></header><div class=entry-content><p>在理解一致性 hash 之前，先来看看这个问题是怎么产生的。 例如我们有一个数据库，里面存了成千上万张图片，用户访问图片会呈现一定的规律性，比如某段时间内一张照片火了，那么短时间内会有大量的请求访问这张图片，会对数据库造成压力，这时候我们就想到要加一层缓存，这也是系统架构的终极法宝。
所以，这种场景下典型的系统架构如下图所示：
客户端要访问文件名为 A 的图片，代理服务器根据文件名去缓存服务器中查询，如果cache中没有，那么最终去数据库取，同时也把取到的图片文件缓存在某个缓存服务器中。 这里有个题外话，通常我们会把文件名 A 通过 hash 函数转换成一段数字，便于操作，这里的 hash 函数与本文的一致性 hash 是不一样的。
那么问题来了：如何将图片均匀的缓存在缓存服务器上呢？
最简单的方式，以文件名为 key，缓存服务器个数为 N，取模得到余数，即 key % N = i，i 是几，就把图片缓存到对应编号的服务器上。
这种方式确实能够将数据 均匀的 分布在缓存上，但是最大的缺点是一旦 N 的数量发生变化，那么几乎所有的 i 都会改变，导致缓存失效。
例如，
key = 5 的文件，在 N = 3 时，缓存在编号为 2 的缓存服务器上。 增加一台服务器，N = 4，那么 key = 5 的文件应该在 1 号服务器上，但事实上它在 2 号。 导致这种情况的根本原因是什么呢？ 我们想让数据均匀分布，但是均匀的算法却依赖于 N ，而 N 直接依赖于服务器的数量！
一致性 Hash 的原理 消除依赖 所以解决的办法就是，让均匀分布的计算方法不依赖于 Redis 的个数 N。...</p></div><footer class=entry-footer><span title='2022-07-09 00:00:00 +0000 UTC'>2022-07-09</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 一致性哈希 Consistent Hashing" href=https://runzhen.github.io/posts/consistent-hashing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>etcd-raft 源码阅读之 raftLog</h2></header><div class=entry-content><p>etcd-raft 有关 log 的实现在分布在log.go，log_unstable.go，storage.go 三个文件中。首先看一下 raftLog 结构体。
raftLog 结构体 type raftLog struct { // storage contains all stable entries since the last snapshot. storage Storage // unstable contains all unstable entries and snapshot. // they will be saved into storage. unstable unstable // committed is the highest log position that is known to be in // stable storage on a quorum of nodes. committed uint64 // applied is the highest log position that the application has // been instructed to apply to its state machine....</p></div><footer class=entry-footer><span title='2022-05-22 00:00:00 +0000 UTC'>2022-05-22</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to etcd-raft 源码阅读之 raftLog" href=https://runzhen.github.io/posts/etcd-raft-raftlog/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>etcd-raft 源码阅读之 Leader 的选举</h2></header><div class=entry-content><p>首先看一下 raft node 之间传递的基本消息（比如 leader 选举，AppendLog）类型 Message protobuf 定义
message Message { optional MessageType type = 1 ; optional uint64 to = 2 ; optional uint64 from = 3 ; // 整个消息发出去时，所处的任期 optional uint64 term = 4 ; // logTerm is generally used for appending Raft logs to followers. For example, // (type=MsgApp,index=100,logTerm=5) means leader appends entries starting at // index=101, and the term of entry at index 100 is 5....</p></div><footer class=entry-footer><span title='2022-05-15 00:00:00 +0000 UTC'>2022-05-15</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to etcd-raft 源码阅读之 Leader 的选举" href=https://runzhen.github.io/posts/etcd-raft-leader-election/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>记一次 go-redis 的 debug 过程</h2></header><div class=entry-content><p>Background 本文背景是这样的: 有一个线上服务使用了 go-redis 库连接 redis，目前 QPS 也不是很高，大约每秒一次的样子，但是通过 log 发现每次 redis 操作花费的时间如下：
redis call cost: 0 ms redis call cost: 2 ms redis call cost: 0 ms redis call cost: 1 ms redis call cost: 0 ms redis call cost: 17 ms redis call cost: 0 ms .... 正常一个简单的 redis get 操作耗费 0-3ms 时间可以理解，但是为什么会出现 17 ms 呢？ 而且出现的频率还不低，大概每 30 个正常的中会出现一个。
尝试 debug 首先总结一下场景和条件
service 部署在 k8s 中，大概 10 个 pod 在运行。 整个 service 的 QPS 大概一秒一个，很低。 高延迟的情况大概每 30 个 log 出现一个。 service 使用简单的 redis get()，没有复杂操作。 但是 service 本身是有很多 go routine 并发的。 所以可能出现问题的地方...</p></div><footer class=entry-footer><span title='2022-05-01 00:00:00 +0000 UTC'>2022-05-01</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 记一次 go-redis 的 debug 过程" href=https://runzhen.github.io/posts/go-redis-latency-debug/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>使用 Kubernetes 遇到的一些问题和解决思路</h2></header><div class=entry-content><p>update on 2022-05-21
今天在 homelab 的 k8s 集群上发生了同样的情况，我想删除一个 namespace，再确认已经把 namespace 里面所有其他资源都删除的情况下，namespace 始终是 Terminating, 找了很多资料，方法也众说纷纭 。
最后通过看 api-server log 发现原来又是 Unable to authenticate the request due to an error: x509: certificate has expired or is not yet valid
root cause 还是我更新 cert 的时候又漏了某些步骤。
事情的起因是 k8s 的 cert 过期了，在目录 /etc/kubernetes/pki/ 下面的这些 cert 都与 k8s 的核心服务息息相关，因此 cert 过期了，整个 k8s 集群就停止服务了。
这个集群是 kubernetes 1.14, 因此需要运行几个命令完成更新，而 1.15 版本以上这个过程简化了不少。 由于之前已经 renew cert 两次了，因此正常按部就班几个操作就完事了，但是这个因为一点小疏忽，加上系统死机重启了一次，花了很多时间去恢复各种服务。
本文记录 debug 的过程中遇到的一些症状，以及后来发现的解决方法，为以后遇到类似问题提供思路。...</p></div><footer class=entry-footer><span title='2022-04-27 00:00:00 +0000 UTC'>2022-04-27</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 使用 Kubernetes 遇到的一些问题和解决思路" href=https://runzhen.github.io/posts/k8s-debug-stories/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>gRPC client 如何实现 TCP 重连</h2></header><div class=entry-content><p>之前写过一篇 gRPC-go 建立 TCP 连接的过程 博客，主要研究了 client 程序启动后，如何与 server 建立 TCP 连接。
今天，在思考 redis-go 的连接池实现的时候，突然想到：
当 gRPC 的 TCP 连接断开后，能自动重连吗？ 如果可以，是如何实现的 ？ 首先要注意，这里指的是 TCP 连接，而不是 http2 中的 stream。 我们知道，gRPC 数据的传输使用 http2 的多路复用，也就是在一个 TCP 连接上有多个全双工的 http2 stream，这里的 stream 如果被断开后怎么重连与 http2 的实现有关，不在本文讨论范围。
对于上面第一个问题，使用 gRPC 的经验告诉我是可以自动重连的，不妨再做个简单的测试，client 端代码如下：
func main() { conn, _ := grpc.Dial("127.0.0.1:8080", grpc.WithInsecure()) defer conn.Close() cli := protobuf.NewTestClient(conn) req := &amp;protobuf.EchoRequest{ Msg: "hi", } for i := 0; i &lt; 10000; i++ { time....</p></div><footer class=entry-footer><span title='2022-04-04 00:00:00 +0000 UTC'>2022-04-04</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to gRPC client 如何实现 TCP 重连" href=https://runzhen.github.io/posts/how-does-grpc-client-reconnect-tcp/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://runzhen.github.io/posts/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://runzhen.github.io/posts/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://runzhen.github.io/>Mind in the Wind</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>