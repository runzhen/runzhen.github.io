<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Blog | Mind in the Wind</title>
<meta name=keywords content><meta name=description content="Blog - Mind in the Wind"><meta name=author content="Me"><link rel=canonical href=https://runzhen.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.103f87022495ee8537d399aa50bf7e2203f4c653b709467478c7fd5a58182364.css integrity="sha256-ED+HAiSV7oU305mqUL9+IgP0xlO3CUZ0eMf9WlgYI2Q=" rel="preload stylesheet" as=style><link rel=icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://runzhen.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://runzhen.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Blog"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://runzhen.github.io/posts/"><meta property="og:image" content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="Mind in the Wind"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Blog"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://runzhen.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://runzhen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://runzhen.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://runzhen.github.io/posts/ title=Blog><span class=active>Blog</span></a></li><li><a href=https://runzhen.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://runzhen.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://runzhen.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Blog
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>docker exec 是如何实现交互的</h2></header><div class=entry-content><p>docker exec 命令的作用是进入到“容器内部”，并执行一些命令，那么它是如何实现把“容器内部”的 io 重定向到我们的终端(bash) 的呢？
基本原理 首先，要明白容器所依赖的内核 namespace 的概念，其实不存在“容器内部”，只要两个进程在相同的 namespace，那它们就相互可见，从用户的角度来说，也就是进入了容器內部。
nsenter nsenter 是一个命令行工具，它可以运行一个 binary，并且把它加入到指定的 namespace 中。
用法如下,
nsenter -h nsenter -a -t &lt;pid> &lt;command> nsenter -m -u -i -n -p -t &lt;pid> &lt;command> 假设有一个 redis container 正在运行，通过 docker inspect --format {{.State.Pid}} 获取 pid, 假设为 2929。
然后运行 nsenter 命令：
# nsenter -a -t 2929 ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND redis 1 0.0 0.0 52968 7744 ? Ssl May17 0:19 redis-server *:6379 root 93 0.0 0.0 7640 2748 ? R+ 05:47 0:00 ps aux 可以看到，ps 命令输出了 “容器內部” 的进程： redis 和 ps，符合我们的预期。
...</p></div><footer class=entry-footer><span title='2021-05-17 00:00:00 +0000 UTC'>2021-05-17</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to docker exec 是如何实现交互的" href=https://runzhen.github.io/posts/docker-exec-io-stream/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang Channel 用法总结</h2></header><div class=entry-content><p>之前的博客中已经粗略探究了一下 golang channel 的实现原理，本文总结一下使用 channel 的各种姿势。
先看一下对不同状态的 channel 的读，写，关闭操作的结果
1. 使用 for range 读取 channel 场景： 当需要不断从 channel 里读数据时
这是最常用的方式，又安全又便利，当channel 被关闭时，for 循环自动退出。 用法不再赘述。
2. 使用 _, ok 判断 channel 是否关闭 场景: 读 channel，但需要判断 channel 是否已关闭。
读 channel 的操作 &lt;- chan 既可以返回一个值，也可以返回两个值，这里就是用的两个返回值的方式。
举例：
if v, ok := &lt;- ch; ok { // can read channel fmt.Println(v) } 读到数据，并且通道没有关闭时，ok 的值为 true。 通道关闭，无数据读到时，ok 的值为 false。 3. 与 select 搭配使用 场景: 需要对多个通道进行处理，或者设置超时
举例：
func (h *Handler) handle(job *Job) { select { case h.jobCh&lt;-job: return case &lt;-h.stopCh: return case &lt;- time.After(2): } } 这里有一个坑需要注意： 当 channel 为 nil，也就是没有初始化时，无论对应的 select case 是读还是写，都会立即返回。 而一般情况下，对 nil channel 的 写操作是要panic的。
...</p></div><footer class=entry-footer><span title='2021-05-14 00:00:00 +0000 UTC'>2021-05-14</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Golang Channel 用法总结" href=https://runzhen.github.io/posts/golang-channel-usage/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>如何设计一个连接池</h2></header><div class=entry-content><p>事情的起因是我在 k8s 中部署了一个 redis，然后 service A 使用 go-redis 库连接 redis。
这个时候我想到： service Pod 和 redis Pod 启动的顺序是不一定的，可能是 service Pod 先启动，此时 redis pod 还没有启动；又或者 redis pod 中途 restart 了。 go-redis 库能正确的处理重连吗？
简单的用 kubectl 命令删除、 重启了 redis，发现 service Pod 能自动恢复连接，说明 go-redis 正确进行了处理，那么它是怎么做的呢 ？
在寻找答案之前，先来想想如果是我自己实现，需要哪些功能？ 该怎么实现？
conn pool 需要自动删除已经断开的、坏掉的连接。 (开一个 goroutine 定期检查即可) 能自动新建连接，补齐一定数量的 conn。 (也不难，goroutine 即可) 如何检测一个 conn 是不是出错了？ 对外的接口是 Get 和 Put，除了正常的用 mutext 控制并发以外，还有什么特殊的操作吗？ go-redis 源码位于 redis/v8/internal/pool/pool.go , 首先看 pool.Options 数据结构
type Options struct { PoolSize int // 连接池数量 MinIdleConns int // 最小空闲连接数 MaxConnAge time.Duration // 连接最大生存时间 PoolTimeout time.Duration // IdleTimeout time.Duration // 空闲超时时间 IdleCheckFrequency time.Duration } 然后看 pool.ConnPool 结构体
...</p></div><footer class=entry-footer><span title='2021-05-01 00:00:00 +0000 UTC'>2021-05-01</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 如何设计一个连接池" href=https://runzhen.github.io/posts/go-redis-conn-pool/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>如何实现一个 kubectl-debug</h2></header><div class=entry-content><p>借助 k8s client-go 连接 API Server，并进行简单的 list 操作，创建 deployment 如何在 pod 内创建 container 如何让 container 加入到某个 Pod 中，并共享 namespace 如何让 pod 内部的 tty 操作结果显示在用户端 docker exec 和 直接 nsenter 还是不太一样的：
docker exec， OCI-O 的实现是启动一个 grpc server，重定向 IO，等于是把 container 的 IO stream 重定向到 用户 cli nsenter 则是启动一个 进程，然后加入到 container 的 ns 所以 前者不需要知道 container 的 pid，而后者需要知道，所以后者需要执行 docker insepect 命令。 观察上图，分析原理，不难发现，容器内部的进程关系已然不是树。然而，为什么总是强调“树状”关系呢？答案是：树状的继承关系，有利于容器管理。以上文《docker logs 实现剖析》中卖的关子「docker exec的标准输出不会作为容器日志」为例，Docker Daemon 创建容器主进程时，负责接管主进程的标准输出，从而保证容器主进程下所有进程的标准输出被接管，然而 Docker Daemon 在新创建 docker exec 所需执行的进程时，后者的标准输出并未与容器主进程作关联，也并未被 Docker Daemon 特殊处理，故 docker exec 所执行进程的标准输出不会进入容器的日志文件中。
...</p></div><footer class=entry-footer><span title='2021-04-24 00:00:00 +0000 UTC'>2021-04-24</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 如何实现一个 kubectl-debug" href=https://runzhen.github.io/posts/how-to-implement-kubectl-debug/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Goroutine 的 PMG 模型</h2></header><div class=entry-content><p>稍微了解过 Go runtime 的人想必都听过 goroutine 的 PMG 模型，哪么它到底代表什么意思呢？ Golang 源码中又是如何实现的？
前言 关于 PMG 的解释网上有很对，随便 copy 一个：
M 代表 Machine，系统线程，它由操作系统管理的，goroutine就是跑在M之上的；M 是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。 P 是 Processor，处理器，它的主要用途就是用来执行goroutine的，它维护了一个goroutine队列，即runqueue。Processor是让我们从N:1调度到M:N调度的重要部分。 G 代表 goroutine 它包含了栈，指令指针，以及其他对调度goroutine很重要的信息，例如其阻塞的channel。 通常 go 程序中可以用 GOMAXPROCS 设置 Processor 的个数； 而 M 则是 clone系统调用创建的，或者用linux pthread 库创建出来的线程实体。 M 与 P 是一对一的关系。
基本结构体 打开 src/runtime/runtime2.go 文件，p,m,g 三个结构体的定义是按顺序在一起的，除此之外还有一个 schedt，与 goroutine 的调度相关。
g 结构体 G 就是 goroutine 的意思，每个 Goroutine 对应一个 g 结构体，它有自己的栈内存, G 存储 Goroutine 的运行堆栈、状态以及任务函数。 当一个 goroutine 退出时，g 会被放到一个空闲的对象池中以用于后续的 goroutine 的使用， 以减少内存分配开销。
...</p></div><footer class=entry-footer><span title='2021-04-19 00:00:00 +0000 UTC'>2021-04-19</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Goroutine 的 PMG 模型" href=https://runzhen.github.io/posts/golang-runtime-pmg-1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kubernetes Scheduler 设计与实现 (一)</h2></header><div class=entry-content><p>Scheduler 的工作就是决定让一个 pod 在哪个 node 上运行。 scheduler 从 API Server 获得 pod 和 node 的信息，然后把它的决策信息写会 API Server, 它自己不参与具体的调度，而是运行在每个 node 上的 kubelet 主动获取更新，然后启动 pod。
scheduler 的入口函数在 cmd/kube-schduler/server.go，但实际工作都是在 pkg/scheduler/scheduler.go 里面的 Run 函数开始的。
打开 scheduler.go 文件找到结构体 Scheduler ，会发现它有很多私有函数，但只有唯一一个公开的 Run() 函数。
先从 Scheduler 结构体来说一下调度器的整体思路，其中最重要的三个成员如下：
type Scheduler struct { Algorithm core.ScheduleAlgorithm NextPod func() *framework.QueuedPodInfo SchedulingQueue internalqueue.SchedulingQueue } Algorithm 就是具体调度的算法 SchedulingQueue 是等待调度的队列，它本身是一个接口，它的实现是 PriorityQueue ，位于 pkg/scheduler/internal/queue/scheduling_queue.go NextPod 获取等待调度的 pod 另外顺便提一下，kubernetes 中的调度队列是由三个队列组成，分别是：
activeQueue：待调度的 pod 队列，scheduler 会监听这个队列 backoffQueue：在 kubernetes 中，如果调度失败了，就相当于一次 backoff。 backoffQueue 专门用来存放 backoff 的 pod。 unschedulableQueue：调度过程被终止的 pod 存放的队列。 然后来看 Scheduler 的 Run 函数:
...</p></div><footer class=entry-footer><span title='2021-04-17 00:00:00 +0000 UTC'>2021-04-17</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kubernetes Scheduler 设计与实现 (一)" href=https://runzhen.github.io/posts/k8s-scheduler-beginning/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang Channel 的实现</h2></header><div class=entry-content><p>Channel 可以说是 Go 语言最具特色的设计了，我们经常会看到一些老鸟这样教育菜鸟：
Do not communicate by sharing memory; instead, share memory by communicating.
那么熟练使用 Golang 就离不开 channel，有必要了解一下 channel 是怎么实现的。
channel 的源代码在 Golang 的 src/runtime/chan.go 目录下，先看结构体:
type hchan struct { qcount uint // 循环列表元素个数 dataqsiz uint // 循环队列的大小 buf unsafe.Pointer // 循环队列的指针 elemsize uint16 // channel 中元素的大小 closed uint32 // 是否已close elemtype *_type // channel 中元素类型 sendx uint // send 在buffer中的索引 recvx uint // recv 在buffer中的索引 recvq waitq // receiver 的等待队列 sendq waitq // sender 的等待队列 lock mutex } type waitq struct { first *sudog last *sudog } 其中
qcount 代表 channel 已经接收但还没被取走的元素的个数 recvq 和 sendq 表示等待接收数据 和等待发送数据的 goroutine 队列 （用 sudog 结构表示） 举例来说，假设用make(chan int, 100) 创建了带100个缓冲区的 channel，qcount 代表缓冲区中元素个数，dataqsiz = 100， recvq 代表等待读数据的 goroutine，而当缓冲区满了以后，sendq 代表阻塞的 goroutine
...</p></div><footer class=entry-footer><span title='2021-04-10 00:00:00 +0000 UTC'>2021-04-10</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Golang Channel 的实现" href=https://runzhen.github.io/posts/golang-channel/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang WaitGroup 的实现</h2></header><div class=entry-content><p>sync.WaitGroup 的作用就是让主函数等待所有 goroutine 都执行完毕，再退出。
一个最简单的例子如下，如果没有 wg，那么 main 会在 goroutine 执行之前就退出，从而不会看到任何 output。
func main() { wg := sync.WaitGroup{} for i := 0; i &lt; 3; i++ { wg.Add(1) go func(i int) { fmt.Println(i) wg.Done() }(i) } wg.Wait() } 那么 WaitGroup 是如何实现的呢？
万变不离其宗，其底层还是基于 go runtime 提供的信号量机制，也就是 runtime_Semrelease() 和 runtime_Semacquire()， 在之前的文章 Golang RWMutex 的实现 和 netpoll 的实现 中都有它们的影子存在。
runtime_Semacquire(s *uint32) 此函数会阻塞直到信号量*s的值大于0，原子减这个值。 runtime_Semrelease(s *uint32, lifo bool, skipframes int) 此函数执行原子增信号量的值，然后通知被runtime_Semacquire阻塞的协程 说到底，就是用 信号量 和 gopark 来控制 goroutine 是运行还是挂起，wg.Add() 对应信号量的增减，wg.Wait() 对应线程/协程的挂起。
WaitGroup 的源码位于 src/sync/waitgroup.go 文件中，一共才 100 多行，下面就逐一分析下。
WaitGroup type WaitGroup struct { noCopy noCopy state1 [3]uint32 } 其中 noCopy 是干啥的呢？ 搜索一番以后发现了这样的解释：
...</p></div><footer class=entry-footer><span title='2021-04-05 00:00:00 +0000 UTC'>2021-04-05</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Golang WaitGroup 的实现" href=https://runzhen.github.io/posts/golang-waitgroup/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang reflect 的使用</h2></header><div class=entry-content><p>所谓反射 (refection) 是指程序在运行过程中获取变量的类型、属性。 在 Golang 中，有时我们会看到 reflect.ValueOf() 或者 reflect.TypeOf() 这两个函数，这就是反射出一个变量的值和类型。 gPRC 的实现中也大量运用了反射。
本文主要介绍如何使用 reflect 包，关于 Go 内部是如何实现的将在下一篇文章中介绍。
TypeOf 和 ValueOf 先看一个最简单的例子
type User struct { Name string Age int } func main() { u := User{"Dick", 18} t := reflect.TypeOf(u) v := reflect.ValueOf(u) fmt.Printf("u type = %T, %v\n", u, u) fmt.Printf("t type = %T, %v\n", t, t) fmt.Printf("v type = %T, %v\n", v, v) // 获取 v 的值 // v.Age , 错误，因为 v 是 reflect.Value 类型 // 正确方式如下 v1 := v.Interface().(User) } 以上代码运行结果如下：
u type = main.User, {Dick 18} t type = *reflect.rtype, main.User v type = reflect.Value, {Dick 18} 可以看出，使用 reflect.ValueOf 返回的是一个 reflect.Value 类型，需要先通过 Interface() 函数返回成一个 interface 类型，再做强制类型转换。
...</p></div><footer class=entry-footer><span title='2021-04-03 00:00:00 +0000 UTC'>2021-04-03</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Golang reflect 的使用" href=https://runzhen.github.io/posts/golang-reflect/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang io 包的实现</h2></header><div class=entry-content><p>Golang 的 io package 包含 3 个文件 io.go, multi.go, pipe.go, 其中最主要的时 io.go。
当我们打开 io.go 的源码后，发现这个文件里面定义了大量的接口，实际上，io 包的作用就是如此 - 定义基本的 Read / Write inteface，而把具体的实现交给其他 package，比如 strings package 中就专门实现了 reader/writer，在后面的文章中再分析 strings 包。
接下来就看看 io 包中到底包含了哪些东西。
io.go 首先时定义了 4 个基础操作，读，写，关闭，seek
type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } type Closer interface { Close() error } type Seeker interface { Seek(offset int64, whence int) (int64, error) } 基于这 4 个基础 interface，两两组合，有扩展了下面几个 interface
ReadWriter ReadCloser WriteCloser ReadWriteCloser ReadSeeker WriteSeeker ReadWriteSeeker 这块内容直接看源码即可，不再赘述。
如果使用 Goland IDE 的话，打开 struct 视图就能很清楚的看到有哪些接口，那些 public 函数。
...</p></div><footer class=entry-footer><span title='2021-04-02 00:00:00 +0000 UTC'>2021-04-02</span>&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Golang io 包的实现" href=https://runzhen.github.io/posts/golang-io-package/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://runzhen.github.io/posts/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://runzhen.github.io/posts/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://runzhen.github.io/>Mind in the Wind</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>