<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>读书笔记 - ByteGraph 和 OceanBase | Mind in the Wind</title>
<meta name=keywords content="reading"><meta name=description content="本周阅读了 VLDB 2022 的两篇论文，做一些简单的读书笔记。 PDF 以及阅读过程中划的重点都在 GoodNotes 里。
ByteGraph ByteGraph 是字节跳动开发的一个分布式图数据库。之前只是听说过图数据库，但并没有用过，因此在阅读的过程中难免对一些概念理解的不够深入。
为什么字节要开发图数据库呢？因为字节的产品都是社交App，因此用户，短视频，专注，点赞，粉丝所有的这些构成了一个巨大的图。
为什么现有的数据库无法满足呢？ 关系型数据库和文档型数据库显然不适合这样的应用场景，比如要获取两个用户之间的关系，即图中两个节点之间的路径，这个路径可以是关注，可以是都点赞了某个视频，关系型数据库无法满足性能需求。其他的图数据库有的是单机，有的是单 master，都不满足要求，因此需要造轮子。
字节的 Workload 分成了 3 种，比我平时听说的多了一种
OLTP，在线处理，比如一个用户发布了新文章，那么 (user,article),(user,tag), (article,tag) 这三条边就要被插入数据库。 OLAP，在线分析数据，一次需要查询大量数据做分析，比如做风险管理分析。 OLSP，这个第一次听说，Online Serving Processing。比如一个用户点赞了某个视频，那么后台需要实时计算他的喜好，然后推荐类似的视频。 整体架构如下所示：
BGE, ByteGraph Execution Engine 负责执行 SQL 语句。 BGS, A cache layer in ByteGraph，负责存储相关。 底层的 KV Stroage 可以选用 RocksDB 或者 TerarkDB。 BGE 使用了 Gremlin 作为解析 query language 的解析器，这是一个专门用于图查询的工具。用户输入的查询语句经过 Gremlin 生成 execution plan 然后传给 BGE。
既然是查询引起，那么就涉及到分布式事务，BGE也是用了 2PC。
上图可以直观的显示 ByteGraph 数据库中所存的数据，可见 KV store 是比较适合存这类数据的，因此 BG 的最底层是 KV store。"><meta name=author content="Me"><link rel=canonical href=https://runzhen.github.io/posts/2022-10-reading-notes/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.a8f620eb24ba9442cd3765590f9208a0752be50e5a7b9dd9e3e555c8cb5e74e6.css integrity="sha256-qPYg6yS6lELNN2VZD5IIoHUr5Q5ae53Z4+VVyMtedOY=" rel="preload stylesheet" as=style><link rel=icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://runzhen.github.io/posts/2022-10-reading-notes/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="读书笔记 - ByteGraph 和 OceanBase"><meta property="og:description" content="本周阅读了 VLDB 2022 的两篇论文，做一些简单的读书笔记。 PDF 以及阅读过程中划的重点都在 GoodNotes 里。
ByteGraph ByteGraph 是字节跳动开发的一个分布式图数据库。之前只是听说过图数据库，但并没有用过，因此在阅读的过程中难免对一些概念理解的不够深入。
为什么字节要开发图数据库呢？因为字节的产品都是社交App，因此用户，短视频，专注，点赞，粉丝所有的这些构成了一个巨大的图。
为什么现有的数据库无法满足呢？ 关系型数据库和文档型数据库显然不适合这样的应用场景，比如要获取两个用户之间的关系，即图中两个节点之间的路径，这个路径可以是关注，可以是都点赞了某个视频，关系型数据库无法满足性能需求。其他的图数据库有的是单机，有的是单 master，都不满足要求，因此需要造轮子。
字节的 Workload 分成了 3 种，比我平时听说的多了一种
OLTP，在线处理，比如一个用户发布了新文章，那么 (user,article),(user,tag), (article,tag) 这三条边就要被插入数据库。 OLAP，在线分析数据，一次需要查询大量数据做分析，比如做风险管理分析。 OLSP，这个第一次听说，Online Serving Processing。比如一个用户点赞了某个视频，那么后台需要实时计算他的喜好，然后推荐类似的视频。 整体架构如下所示：
BGE, ByteGraph Execution Engine 负责执行 SQL 语句。 BGS, A cache layer in ByteGraph，负责存储相关。 底层的 KV Stroage 可以选用 RocksDB 或者 TerarkDB。 BGE 使用了 Gremlin 作为解析 query language 的解析器，这是一个专门用于图查询的工具。用户输入的查询语句经过 Gremlin 生成 execution plan 然后传给 BGE。
既然是查询引起，那么就涉及到分布式事务，BGE也是用了 2PC。
上图可以直观的显示 ByteGraph 数据库中所存的数据，可见 KV store 是比较适合存这类数据的，因此 BG 的最底层是 KV store。"><meta property="og:type" content="article"><meta property="og:url" content="https://runzhen.github.io/posts/2022-10-reading-notes/"><meta property="og:image" content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-20T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-20T00:00:00+00:00"><meta property="og:site_name" content="Mind in the Wind"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="读书笔记 - ByteGraph 和 OceanBase"><meta name=twitter:description content="本周阅读了 VLDB 2022 的两篇论文，做一些简单的读书笔记。 PDF 以及阅读过程中划的重点都在 GoodNotes 里。
ByteGraph ByteGraph 是字节跳动开发的一个分布式图数据库。之前只是听说过图数据库，但并没有用过，因此在阅读的过程中难免对一些概念理解的不够深入。
为什么字节要开发图数据库呢？因为字节的产品都是社交App，因此用户，短视频，专注，点赞，粉丝所有的这些构成了一个巨大的图。
为什么现有的数据库无法满足呢？ 关系型数据库和文档型数据库显然不适合这样的应用场景，比如要获取两个用户之间的关系，即图中两个节点之间的路径，这个路径可以是关注，可以是都点赞了某个视频，关系型数据库无法满足性能需求。其他的图数据库有的是单机，有的是单 master，都不满足要求，因此需要造轮子。
字节的 Workload 分成了 3 种，比我平时听说的多了一种
OLTP，在线处理，比如一个用户发布了新文章，那么 (user,article),(user,tag), (article,tag) 这三条边就要被插入数据库。 OLAP，在线分析数据，一次需要查询大量数据做分析，比如做风险管理分析。 OLSP，这个第一次听说，Online Serving Processing。比如一个用户点赞了某个视频，那么后台需要实时计算他的喜好，然后推荐类似的视频。 整体架构如下所示：
BGE, ByteGraph Execution Engine 负责执行 SQL 语句。 BGS, A cache layer in ByteGraph，负责存储相关。 底层的 KV Stroage 可以选用 RocksDB 或者 TerarkDB。 BGE 使用了 Gremlin 作为解析 query language 的解析器，这是一个专门用于图查询的工具。用户输入的查询语句经过 Gremlin 生成 execution plan 然后传给 BGE。
既然是查询引起，那么就涉及到分布式事务，BGE也是用了 2PC。
上图可以直观的显示 ByteGraph 数据库中所存的数据，可见 KV store 是比较适合存这类数据的，因此 BG 的最底层是 KV store。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://runzhen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"读书笔记 - ByteGraph 和 OceanBase","item":"https://runzhen.github.io/posts/2022-10-reading-notes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"读书笔记 - ByteGraph 和 OceanBase","name":"读书笔记 - ByteGraph 和 OceanBase","description":"本周阅读了 VLDB 2022 的两篇论文，做一些简单的读书笔记。 PDF 以及阅读过程中划的重点都在 GoodNotes 里。\nByteGraph ByteGraph 是字节跳动开发的一个分布式图数据库。之前只是听说过图数据库，但并没有用过，因此在阅读的过程中难免对一些概念理解的不够深入。\n为什么字节要开发图数据库呢？因为字节的产品都是社交App，因此用户，短视频，专注，点赞，粉丝所有的这些构成了一个巨大的图。\n为什么现有的数据库无法满足呢？ 关系型数据库和文档型数据库显然不适合这样的应用场景，比如要获取两个用户之间的关系，即图中两个节点之间的路径，这个路径可以是关注，可以是都点赞了某个视频，关系型数据库无法满足性能需求。其他的图数据库有的是单机，有的是单 master，都不满足要求，因此需要造轮子。\n字节的 Workload 分成了 3 种，比我平时听说的多了一种\nOLTP，在线处理，比如一个用户发布了新文章，那么 (user,article),(user,tag), (article,tag) 这三条边就要被插入数据库。 OLAP，在线分析数据，一次需要查询大量数据做分析，比如做风险管理分析。 OLSP，这个第一次听说，Online Serving Processing。比如一个用户点赞了某个视频，那么后台需要实时计算他的喜好，然后推荐类似的视频。 整体架构如下所示：\nBGE, ByteGraph Execution Engine 负责执行 SQL 语句。 BGS, A cache layer in ByteGraph，负责存储相关。 底层的 KV Stroage 可以选用 RocksDB 或者 TerarkDB。 BGE 使用了 Gremlin 作为解析 query language 的解析器，这是一个专门用于图查询的工具。用户输入的查询语句经过 Gremlin 生成 execution plan 然后传给 BGE。\n既然是查询引起，那么就涉及到分布式事务，BGE也是用了 2PC。\n上图可以直观的显示 ByteGraph 数据库中所存的数据，可见 KV store 是比较适合存这类数据的，因此 BG 的最底层是 KV store。","keywords":["reading"],"articleBody":"本周阅读了 VLDB 2022 的两篇论文，做一些简单的读书笔记。 PDF 以及阅读过程中划的重点都在 GoodNotes 里。\nByteGraph ByteGraph 是字节跳动开发的一个分布式图数据库。之前只是听说过图数据库，但并没有用过，因此在阅读的过程中难免对一些概念理解的不够深入。\n为什么字节要开发图数据库呢？因为字节的产品都是社交App，因此用户，短视频，专注，点赞，粉丝所有的这些构成了一个巨大的图。\n为什么现有的数据库无法满足呢？ 关系型数据库和文档型数据库显然不适合这样的应用场景，比如要获取两个用户之间的关系，即图中两个节点之间的路径，这个路径可以是关注，可以是都点赞了某个视频，关系型数据库无法满足性能需求。其他的图数据库有的是单机，有的是单 master，都不满足要求，因此需要造轮子。\n字节的 Workload 分成了 3 种，比我平时听说的多了一种\nOLTP，在线处理，比如一个用户发布了新文章，那么 (user,article),(user,tag), (article,tag) 这三条边就要被插入数据库。 OLAP，在线分析数据，一次需要查询大量数据做分析，比如做风险管理分析。 OLSP，这个第一次听说，Online Serving Processing。比如一个用户点赞了某个视频，那么后台需要实时计算他的喜好，然后推荐类似的视频。 整体架构如下所示：\nBGE, ByteGraph Execution Engine 负责执行 SQL 语句。 BGS, A cache layer in ByteGraph，负责存储相关。 底层的 KV Stroage 可以选用 RocksDB 或者 TerarkDB。 BGE 使用了 Gremlin 作为解析 query language 的解析器，这是一个专门用于图查询的工具。用户输入的查询语句经过 Gremlin 生成 execution plan 然后传给 BGE。\n既然是查询引起，那么就涉及到分布式事务，BGE也是用了 2PC。\n上图可以直观的显示 ByteGraph 数据库中所存的数据，可见 KV store 是比较适合存这类数据的，因此 BG 的最底层是 KV store。\n实现 5.1 分布式事务处理 前面提到，分布式事务处理用的是 2PC。值得一提的是，BG 不支持 MVCC\n5.2 高可用和容错 如果一台 BGS 挂了，BGE 收不到心跳信息以后，就会把 request 转发给 hash ring 上的下一个 BGS。没错，这里也用到了一致性 hash，并且了一个改进版本的 weighted consistent hashing algorithm。\n与 Spanner 用原子钟不同，ByteGraph 没有财大气粗到用这么高端的东西，BG 用了 Hybrid Logic Clock (HLC) 来避免 clock skew。 在 OceanBase 论文中，没有明确说 OB 用了那种 logic clock，但是在 7.2 节中提到了 cockroachDB 也是用的 HLC。\n在记录 log 上，BG 使用了 WAL 的方式。\nOceanBase 文章开篇就讲了 OceanBase 的特点： Multi-Tenant, Shared-Nothing, 可以部署 on-premise 或者 off-premise, 同时有 SQL 查询，是一个 HAP 性数据库。\n整个系统设计分一下几个方面\n架构 可以跨 region 多个 zone，每一个 数据库表都被 partition 为多个小的表，这样能存到不同 region/zone 的节点上，而且每个 partition 都有副本 replica。这些副本用 Paxos 算法管理。\nSQL Engine 解析用户输入的 SQL 语句总是耗时的，因此 OB 用了一个轻量级的框架做词法分析，然后取 cache 中匹配，如果匹配到了就不需要做后续的语法分析、生成 exection plan 等步骤了。\n说白了，还是用 cache 空间换时间。\nMulti Tenancy 一个系统级 tenant，其他的都是普通 tenant。\n资源隔离在概念上类似 Docker 和 VM，但 OB 是自己做的。 OB 做到 CPU、内存、数据结构（SQL exection plan 的 cache）、transaction 相关的结构 的隔离。\nStorage Engine 基于 LSM Tree，但是在做 Daily Incremental Major Compaction 等方面做了优化，这部分看的不是很懂，应该与 LSM 的一些原理相关。\nTransaction 无外乎就是两阶段提交 2PC，但是 OB 基于 2PC 设计了自己的 OceanBase 2PC。\n除以上外，还有 Isolation Level 和 Replicated Table 部分，这部分也不是很懂。\nLessons In Building OceanBase 这个是本文最有意思的部分，提到了 OB 发展将近 10 年之间的一些演变，同时还对比了一些流行的分布式数据库。\n我的总结 论文在技术、架构上只是提纲挈领，无法涉及更多的细节，看下来感觉数据库系统就是这么设计的，大同小异，无外乎就是 Raft、Paxos、2PC、LSM，ACID、MVCC、Isolation Level、WAL、HLC。\n但是同时也觉得自己在这方面的积累不够，比如 LSM tree，虽然各家数据库都用了，但是每家在阐述自己的优化时，就读的云里雾里。\n另一方面，感觉很多概念 DDIA 这本书里也看了，但是在论文中看到这些概念时，还是不了解他们在一个数据库系统中起的作用，比如 2PC，Isolation Level，看来再读一遍 DDIA 还是很有必要。\n","wordCount":"245","inLanguage":"en","image":"https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-10-20T00:00:00Z","dateModified":"2022-10-20T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://runzhen.github.io/posts/2022-10-reading-notes/"},"publisher":{"@type":"Organization","name":"Mind in the Wind","logo":{"@type":"ImageObject","url":"https://runzhen.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://runzhen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://runzhen.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://runzhen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://runzhen.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://runzhen.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://runzhen.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">读书笔记 - ByteGraph 和 OceanBase</h1><div class=post-meta><span title='2022-10-20 00:00:00 +0000 UTC'>2022-10-20</span>&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#bytegraph aria-label=ByteGraph>ByteGraph</a><ul><li><a href=#%e5%ae%9e%e7%8e%b0 aria-label=实现>实现</a><ul><li><a href=#51-%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1%e5%a4%84%e7%90%86 aria-label="5.1 分布式事务处理">5.1 分布式事务处理</a></li><li><a href=#52-%e9%ab%98%e5%8f%af%e7%94%a8%e5%92%8c%e5%ae%b9%e9%94%99 aria-label="5.2 高可用和容错">5.2 高可用和容错</a></li></ul></li></ul></li><li><a href=#oceanbase aria-label=OceanBase>OceanBase</a><ul><li><a href=#%e6%9e%b6%e6%9e%84 aria-label=架构>架构</a></li><li><a href=#sql-engine aria-label="SQL Engine">SQL Engine</a></li><li><a href=#multi-tenancy aria-label="Multi Tenancy">Multi Tenancy</a></li><li><a href=#storage-engine aria-label="Storage Engine">Storage Engine</a></li><li><a href=#transaction aria-label=Transaction>Transaction</a></li><li><a href=#lessons-in-building-oceanbase aria-label="Lessons In Building OceanBase">Lessons In Building OceanBase</a></li></ul></li><li><a href=#%e6%88%91%e7%9a%84%e6%80%bb%e7%bb%93 aria-label=我的总结>我的总结</a></li></ul></div></details></div><div class=post-content><p>本周阅读了 VLDB 2022 的两篇论文，做一些简单的读书笔记。 PDF 以及阅读过程中划的重点都在 GoodNotes 里。</p><h2 id=bytegraph>ByteGraph<a hidden class=anchor aria-hidden=true href=#bytegraph>#</a></h2><p>ByteGraph 是字节跳动开发的一个<strong>分布式图数据库</strong>。之前只是听说过图数据库，但并没有用过，因此在阅读的过程中难免对一些概念理解的不够深入。</p><p>为什么字节要开发图数据库呢？因为字节的产品都是社交App，因此用户，短视频，专注，点赞，粉丝所有的这些构成了一个巨大的图。</p><p>为什么现有的数据库无法满足呢？ 关系型数据库和文档型数据库显然不适合这样的应用场景，比如要获取两个用户之间的关系，即图中两个节点之间的路径，这个路径可以是关注，可以是都点赞了某个视频，关系型数据库无法满足性能需求。其他的图数据库有的是单机，有的是单 master，都不满足要求，因此需要造轮子。</p><p>字节的 Workload 分成了 3 种，比我平时听说的多了一种</p><ol><li>OLTP，在线处理，比如一个用户发布了新文章，那么 (user,article),(user,tag), (article,tag) 这三条边就要被插入数据库。</li><li>OLAP，在线分析数据，一次需要查询大量数据做分析，比如做风险管理分析。</li><li>OLSP，这个第一次听说，Online Serving Processing。比如一个用户点赞了某个视频，那么后台需要实时计算他的喜好，然后推荐类似的视频。</li></ol><p>整体架构如下所示：</p><p><img loading=lazy src=/image/2022/bytegraph.png alt></p><ul><li>BGE, ByteGraph Execution Engine 负责执行 SQL 语句。</li><li>BGS, A cache layer in ByteGraph，负责存储相关。</li><li>底层的 KV Stroage 可以选用 RocksDB 或者 TerarkDB。</li></ul><p>BGE 使用了 Gremlin 作为解析 query language 的解析器，这是一个专门用于图查询的工具。用户输入的查询语句经过 Gremlin 生成 execution plan 然后传给 BGE。</p><p>既然是查询引起，那么就涉及到分布式事务，BGE也是用了 2PC。</p><p><img loading=lazy src=/image/2022/bytegraph2.png alt></p><p>上图可以直观的显示 ByteGraph 数据库中所存的数据，可见 KV store 是比较适合存这类数据的，因此 BG 的最底层是 KV store。</p><h3 id=实现>实现<a hidden class=anchor aria-hidden=true href=#实现>#</a></h3><h4 id=51-分布式事务处理>5.1 分布式事务处理<a hidden class=anchor aria-hidden=true href=#51-分布式事务处理>#</a></h4><p>前面提到，分布式事务处理用的是 2PC。值得一提的是，<code>BG 不支持 MVCC</code></p><h4 id=52-高可用和容错>5.2 高可用和容错<a hidden class=anchor aria-hidden=true href=#52-高可用和容错>#</a></h4><p>如果一台 BGS 挂了，BGE 收不到心跳信息以后，就会把 request 转发给 hash ring 上的下一个 BGS。没错，这里也用到了一致性 hash，并且了一个改进版本的 <code>weighted consistent hashing algorithm</code>。</p><p>与 Spanner 用原子钟不同，ByteGraph 没有财大气粗到用这么高端的东西，BG 用了 <code>Hybrid Logic Clock (HLC)</code> 来避免 clock skew。 在 OceanBase 论文中，没有明确说 OB 用了那种 logic clock，但是在 7.2 节中提到了 cockroachDB 也是用的 HLC。</p><p>在记录 log 上，BG 使用了 WAL 的方式。</p><h2 id=oceanbase>OceanBase<a hidden class=anchor aria-hidden=true href=#oceanbase>#</a></h2><p>文章开篇就讲了 OceanBase 的特点： <code>Multi-Tenant</code>, <code>Shared-Nothing</code>, 可以部署 <code>on-premise</code> 或者 <code>off-premise</code>, 同时有 SQL 查询，是一个 HAP 性数据库。</p><p>整个系统设计分一下几个方面</p><h3 id=架构>架构<a hidden class=anchor aria-hidden=true href=#架构>#</a></h3><p>可以跨 region 多个 zone，每一个 <code>数据库表</code>都被 partition 为多个小的表，这样能存到不同 region/zone 的节点上，而且每个 partition 都有副本 replica。这些副本用 Paxos 算法管理。</p><h3 id=sql-engine>SQL Engine<a hidden class=anchor aria-hidden=true href=#sql-engine>#</a></h3><p>解析用户输入的 SQL 语句总是耗时的，因此 OB 用了一个轻量级的框架做词法分析，然后取 cache 中匹配，如果匹配到了就不需要做后续的语法分析、生成 exection plan 等步骤了。</p><p>说白了，还是用 cache 空间换时间。</p><h3 id=multi-tenancy>Multi Tenancy<a hidden class=anchor aria-hidden=true href=#multi-tenancy>#</a></h3><p>一个系统级 tenant，其他的都是普通 tenant。</p><p>资源隔离在概念上类似 Docker 和 VM，但 OB 是自己做的。 OB 做到 CPU、内存、数据结构（SQL exection plan 的 cache）、transaction 相关的结构 的隔离。</p><h3 id=storage-engine>Storage Engine<a hidden class=anchor aria-hidden=true href=#storage-engine>#</a></h3><p>基于 LSM Tree，但是在做 Daily Incremental Major Compaction 等方面做了优化，这部分看的不是很懂，应该与 LSM 的一些原理相关。</p><h3 id=transaction>Transaction<a hidden class=anchor aria-hidden=true href=#transaction>#</a></h3><p>无外乎就是两阶段提交 2PC，但是 OB 基于 2PC 设计了自己的 OceanBase 2PC。</p><p>除以上外，还有 Isolation Level 和 Replicated Table 部分，这部分也不是很懂。</p><h3 id=lessons-in-building-oceanbase>Lessons In Building OceanBase<a hidden class=anchor aria-hidden=true href=#lessons-in-building-oceanbase>#</a></h3><p>这个是本文最有意思的部分，提到了 OB 发展将近 10 年之间的一些演变，同时还对比了一些流行的分布式数据库。</p><h2 id=我的总结>我的总结<a hidden class=anchor aria-hidden=true href=#我的总结>#</a></h2><p>论文在技术、架构上只是提纲挈领，无法涉及更多的细节，看下来感觉数据库系统就是这么设计的，大同小异，无外乎就是 Raft、Paxos、2PC、LSM，ACID、MVCC、Isolation Level、WAL、HLC。</p><p>但是同时也觉得自己在这方面的积累不够，比如 LSM tree，虽然各家数据库都用了，但是每家在阐述自己的优化时，就读的云里雾里。</p><p>另一方面，感觉很多概念 DDIA 这本书里也看了，但是在论文中看到这些概念时，还是不了解他们在一个数据库系统中起的作用，比如 2PC，Isolation Level，看来再读一遍 DDIA 还是很有必要。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://runzhen.github.io/tags/reading/>Reading</a></li></ul><nav class=paginav><a class=prev href=https://runzhen.github.io/posts/go-asm1/><span class=title>« Prev</span><br><span>看懂 Go 汇编 一</span>
</a><a class=next href=https://runzhen.github.io/posts/latency-numbers-every-programer-should-know/><span class=title>Next »</span><br><span>Latency numbers every programmer should know</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 读书笔记 - ByteGraph 和 OceanBase on x" href="https://x.com/intent/tweet/?text=%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20-%20ByteGraph%20%e5%92%8c%20OceanBase&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2f2022-10-reading-notes%2f&amp;hashtags=reading"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 读书笔记 - ByteGraph 和 OceanBase on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2f2022-10-reading-notes%2f&amp;title=%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20-%20ByteGraph%20%e5%92%8c%20OceanBase&amp;summary=%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20-%20ByteGraph%20%e5%92%8c%20OceanBase&amp;source=https%3a%2f%2frunzhen.github.io%2fposts%2f2022-10-reading-notes%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 读书笔记 - ByteGraph 和 OceanBase on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frunzhen.github.io%2fposts%2f2022-10-reading-notes%2f&title=%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20-%20ByteGraph%20%e5%92%8c%20OceanBase"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 读书笔记 - ByteGraph 和 OceanBase on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frunzhen.github.io%2fposts%2f2022-10-reading-notes%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 读书笔记 - ByteGraph 和 OceanBase on whatsapp" href="https://api.whatsapp.com/send?text=%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20-%20ByteGraph%20%e5%92%8c%20OceanBase%20-%20https%3a%2f%2frunzhen.github.io%2fposts%2f2022-10-reading-notes%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 读书笔记 - ByteGraph 和 OceanBase on telegram" href="https://telegram.me/share/url?text=%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20-%20ByteGraph%20%e5%92%8c%20OceanBase&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2f2022-10-reading-notes%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 读书笔记 - ByteGraph 和 OceanBase on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20-%20ByteGraph%20%e5%92%8c%20OceanBase&u=https%3a%2f%2frunzhen.github.io%2fposts%2f2022-10-reading-notes%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://runzhen.github.io/>Mind in the Wind</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>