<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>gRPC-go 建立 TCP 连接的过程 | Mind in the Wind</title>
<meta name=keywords content="grpc,golang"><meta name=description content='首先看一个最简单的建立 client server 之间 gRPC 连接的代码，以这个代码为例，分析一下 TCP 是在何时建立的。
Server 端的代码相对来说很容易，一个最简单的 server 代码如下：
func main() {
	lis, _ := net.Listen("tcp", fmt.Sprintf(":%d", 8080))
	grpcServer := grpc.NewServer()
	protobuf.RegisterTestServer(grpcServer, &amp;server{})
	grpcServer.Serve(lis)
}
在 grpc/server.go 中的 Serve() 函数调用了 lis.Accept() 并阻塞，当 client 端发来 TCP 请求时，Accept() 返回 Conn 结构，并开启 goroutine handleRawConn() 进行后续的处理。
就 TCP 来说，server 端的代码简单易懂，相比之下 client 端则不一样，一个基本的 Client 代码如下：
func main() {
    conn, err := grpc.Dial("localhost:8080", grpc.WithInsecure())
    defer conn.Close()
    cli := protobuf.NewTestClient(conn)
}
而要弄清楚 Client 端如何建立 TCP 却不容易，这是因为 grpc client 有 resolve DNS 以及做 load balancer 的功能，因此代码复杂很多。
从上面的代码不难看出肯定是在 Dial() 函数中建立的，它的具体实现是在 DialContext(), 返回 ClientConn 结构体指针，但是却看不到在哪建立了 TCP 链接，这是因为 TCP 链接是在一个 Goroutine 中异步建立的。如果想要 DialContext() 等连接建立完再返回，可以指定grpc.WithBlock()传入Options来实现。'><meta name=author content="Me"><link rel=canonical href=https://runzhen.github.io/posts/grpc-client-tcp-connection/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.103f87022495ee8537d399aa50bf7e2203f4c653b709467478c7fd5a58182364.css integrity="sha256-ED+HAiSV7oU305mqUL9+IgP0xlO3CUZ0eMf9WlgYI2Q=" rel="preload stylesheet" as=style><link rel=icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://runzhen.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://runzhen.github.io/posts/grpc-client-tcp-connection/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="gRPC-go 建立 TCP 连接的过程"><meta property="og:description" content='首先看一个最简单的建立 client server 之间 gRPC 连接的代码，以这个代码为例，分析一下 TCP 是在何时建立的。
Server 端的代码相对来说很容易，一个最简单的 server 代码如下：
func main() {
	lis, _ := net.Listen("tcp", fmt.Sprintf(":%d", 8080))
	grpcServer := grpc.NewServer()
	protobuf.RegisterTestServer(grpcServer, &amp;server{})
	grpcServer.Serve(lis)
}
在 grpc/server.go 中的 Serve() 函数调用了 lis.Accept() 并阻塞，当 client 端发来 TCP 请求时，Accept() 返回 Conn 结构，并开启 goroutine handleRawConn() 进行后续的处理。
就 TCP 来说，server 端的代码简单易懂，相比之下 client 端则不一样，一个基本的 Client 代码如下：
func main() {
    conn, err := grpc.Dial("localhost:8080", grpc.WithInsecure())
    defer conn.Close()
    cli := protobuf.NewTestClient(conn)
}
而要弄清楚 Client 端如何建立 TCP 却不容易，这是因为 grpc client 有 resolve DNS 以及做 load balancer 的功能，因此代码复杂很多。
从上面的代码不难看出肯定是在 Dial() 函数中建立的，它的具体实现是在 DialContext(), 返回 ClientConn 结构体指针，但是却看不到在哪建立了 TCP 链接，这是因为 TCP 链接是在一个 Goroutine 中异步建立的。如果想要 DialContext() 等连接建立完再返回，可以指定grpc.WithBlock()传入Options来实现。'><meta property="og:type" content="article"><meta property="og:url" content="https://runzhen.github.io/posts/grpc-client-tcp-connection/"><meta property="og:image" content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-10-11T00:00:00+00:00"><meta property="article:modified_time" content="2020-10-11T00:00:00+00:00"><meta property="og:site_name" content="Mind in the Wind"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="gRPC-go 建立 TCP 连接的过程"><meta name=twitter:description content='首先看一个最简单的建立 client server 之间 gRPC 连接的代码，以这个代码为例，分析一下 TCP 是在何时建立的。
Server 端的代码相对来说很容易，一个最简单的 server 代码如下：
func main() {
	lis, _ := net.Listen("tcp", fmt.Sprintf(":%d", 8080))
	grpcServer := grpc.NewServer()
	protobuf.RegisterTestServer(grpcServer, &amp;server{})
	grpcServer.Serve(lis)
}
在 grpc/server.go 中的 Serve() 函数调用了 lis.Accept() 并阻塞，当 client 端发来 TCP 请求时，Accept() 返回 Conn 结构，并开启 goroutine handleRawConn() 进行后续的处理。
就 TCP 来说，server 端的代码简单易懂，相比之下 client 端则不一样，一个基本的 Client 代码如下：
func main() {
    conn, err := grpc.Dial("localhost:8080", grpc.WithInsecure())
    defer conn.Close()
    cli := protobuf.NewTestClient(conn)
}
而要弄清楚 Client 端如何建立 TCP 却不容易，这是因为 grpc client 有 resolve DNS 以及做 load balancer 的功能，因此代码复杂很多。
从上面的代码不难看出肯定是在 Dial() 函数中建立的，它的具体实现是在 DialContext(), 返回 ClientConn 结构体指针，但是却看不到在哪建立了 TCP 链接，这是因为 TCP 链接是在一个 Goroutine 中异步建立的。如果想要 DialContext() 等连接建立完再返回，可以指定grpc.WithBlock()传入Options来实现。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://runzhen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"gRPC-go 建立 TCP 连接的过程","item":"https://runzhen.github.io/posts/grpc-client-tcp-connection/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"gRPC-go 建立 TCP 连接的过程","name":"gRPC-go 建立 TCP 连接的过程","description":"首先看一个最简单的建立 client server 之间 gRPC 连接的代码，以这个代码为例，分析一下 TCP 是在何时建立的。\nServer 端的代码相对来说很容易，一个最简单的 server 代码如下：\nfunc main() { lis, _ := net.Listen(\u0026#34;tcp\u0026#34;, fmt.Sprintf(\u0026#34;:%d\u0026#34;, 8080)) grpcServer := grpc.NewServer() protobuf.RegisterTestServer(grpcServer, \u0026amp;server{}) grpcServer.Serve(lis) } 在 grpc/server.go 中的 Serve() 函数调用了 lis.Accept() 并阻塞，当 client 端发来 TCP 请求时，Accept() 返回 Conn 结构，并开启 goroutine handleRawConn() 进行后续的处理。\n就 TCP 来说，server 端的代码简单易懂，相比之下 client 端则不一样，一个基本的 Client 代码如下：\nfunc main() { conn, err := grpc.Dial(\u0026#34;localhost:8080\u0026#34;, grpc.WithInsecure()) defer conn.Close() cli := protobuf.NewTestClient(conn) } 而要弄清楚 Client 端如何建立 TCP 却不容易，这是因为 grpc client 有 resolve DNS 以及做 load balancer 的功能，因此代码复杂很多。\n从上面的代码不难看出肯定是在 Dial() 函数中建立的，它的具体实现是在 DialContext(), 返回 ClientConn 结构体指针，但是却看不到在哪建立了 TCP 链接，这是因为 TCP 链接是在一个 Goroutine 中异步建立的。如果想要 DialContext() 等连接建立完再返回，可以指定grpc.WithBlock()传入Options来实现。\n","keywords":["grpc","golang"],"articleBody":"首先看一个最简单的建立 client server 之间 gRPC 连接的代码，以这个代码为例，分析一下 TCP 是在何时建立的。\nServer 端的代码相对来说很容易，一个最简单的 server 代码如下：\nfunc main() { lis, _ := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", 8080)) grpcServer := grpc.NewServer() protobuf.RegisterTestServer(grpcServer, \u0026server{}) grpcServer.Serve(lis) } 在 grpc/server.go 中的 Serve() 函数调用了 lis.Accept() 并阻塞，当 client 端发来 TCP 请求时，Accept() 返回 Conn 结构，并开启 goroutine handleRawConn() 进行后续的处理。\n就 TCP 来说，server 端的代码简单易懂，相比之下 client 端则不一样，一个基本的 Client 代码如下：\nfunc main() { conn, err := grpc.Dial(\"localhost:8080\", grpc.WithInsecure()) defer conn.Close() cli := protobuf.NewTestClient(conn) } 而要弄清楚 Client 端如何建立 TCP 却不容易，这是因为 grpc client 有 resolve DNS 以及做 load balancer 的功能，因此代码复杂很多。\n从上面的代码不难看出肯定是在 Dial() 函数中建立的，它的具体实现是在 DialContext(), 返回 ClientConn 结构体指针，但是却看不到在哪建立了 TCP 链接，这是因为 TCP 链接是在一个 Goroutine 中异步建立的。如果想要 DialContext() 等连接建立完再返回，可以指定grpc.WithBlock()传入Options来实现。\n下面就来剖析一下整个过程。\n先说结论，client 是在 clientconn.go 文件的 connect() 里面 go ac.resetTransport() 建立了到 server 的 TCP 链接的。\n// connect starts creating a transport. // It does nothing if the ac is not IDLE. // TODO(bar) Move this to the addrConn section. func (ac *addrConn) connect() error { ac.mu.Lock() if ac.state == connectivity.Shutdown { ac.mu.Unlock() return errConnClosing } if ac.state != connectivity.Idle { ac.mu.Unlock() return nil } // Update connectivity state within the lock to prevent subsequent or // concurrent calls from resetting the transport more than once. ac.updateConnectivityState(connectivity.Connecting, nil) ac.mu.Unlock() // Start a goroutine connecting to the server asynchronously. go ac.resetTransport() return nil } 接着跟踪 ac.resetTransport(), 调用顺序如下：tryAllAddrs() \u003e createTransport() \u003e NewClientTransport() \u003e newHTTP2Client(), 最终，看到 dial(connectCtx, opts.Dialer, addr.Addr)\n可以在 dial 函数出设置断点验证我们的猜测，当程序执行到断点后，可以通过 netstat 命令查看 tcp 链接。\n# netstat tcp 15 0 127.0.0.1:40972 127.0.0.1:8080 ESTABLISHED 9903/. 并使用 backtrace 验证调用栈\n0 0x0000000000748c02 in google.golang.org/grpc/internal/transport.newHTTP2Client at ./vendor/google.golang.org/grpc/internal/transport/http2_client.go:174 1 0x00000000007c21c8 in google.golang.org/grpc/internal/transport.NewClientTransport at ./vendor/google.golang.org/grpc/internal/transport/transport.go:581 2 0x00000000007c21c8 in google.golang.org/grpc.(*addrConn).createTransport at ./vendor/google.golang.org/grpc/clientconn.go:1300 3 0x00000000007c18ca in google.golang.org/grpc.(*addrConn).tryAllAddrs at ./vendor/google.golang.org/grpc/clientconn.go:1223 4 0x00000000007c0e9f in google.golang.org/grpc.(*addrConn).resetTransport at ./vendor/google.golang.org/grpc/clientconn.go:1133 那么是怎么一步一步从 Dial() 调用到位于 clientconn.go 中的 connect() 函数呢？\n这要从 client 端的 resolve DNS 以及 load balancer 说起，先看一张 gRPC 客户端负载均衡的架构图\n不难看出，client 端挺复杂的，左边是 Resolver 解析器，它主要完成下面这几个功能：\n服务发现的实现 和注册中心（Etcd、CoreDNS、Consul 等）通信，实时获取服务器的列表（或者处理变更信息） 将上步获取的数据发送给 Balancer，以便更新 Connection Pool（内置 gRPC 长连接池） 结合上面的图，我们再来看一下 backtrace，结果符合我们的预期，可以看到，代码先执行到 Resolver，然后到 Balancer。\n0 0x00000000007bf3d3 in google.golang.org/grpc.(*addrConn).connect at ./vendor/google.golang.org/grpc/clientconn.go:799 1 0x00000000007ba408 in google.golang.org/grpc.(*acBalancerWrapper).Connect at ./vendor/google.golang.org/grpc/balancer_conn_wrappers.go:264 2 0x00000000007c59d4 in google.golang.org/grpc.(*pickfirstBalancer).UpdateClientConnState at ./vendor/google.golang.org/grpc/pickfirst.go:102 3 0x00000000007b93ab in google.golang.org/grpc.(*ccBalancerWrapper).updateClientConnState at ./vendor/google.golang.org/grpc/balancer_conn_wrappers.go:127 4 0x00000000007bde7c in google.golang.org/grpc.(*ClientConn).updateResolverState at ./vendor/google.golang.org/grpc/clientconn.go:653 5 0x00000000007c8134 in google.golang.org/grpc.(*ccResolverWrapper).UpdateState at ./vendor/google.golang.org/grpc/resolver_conn_wrapper.go:177 6 0x000000000075efc2 in google.golang.org/grpc/internal/resolver/passthrough.(*passthroughResolver).start at ./vendor/google.golang.org/grpc/internal/resolver/passthrough/passthrough.go:48 7 0x000000000075efc2 in google.golang.org/grpc/internal/resolver/passthrough.(*passthroughBuilder).Build at ./vendor/google.golang.org/grpc/internal/resolver/passthrough/passthrough.go:34 8 0x00000000007c7a31 in google.golang.org/grpc.newCCResolverWrapper at ./vendor/google.golang.org/grpc/resolver_conn_wrapper.go:103 9 0x00000000007bb506 in google.golang.org/grpc.DialContext at ./vendor/google.golang.org/grpc/clientconn.go:301 10 0x00000000007de6ad in google.golang.org/grpc.Dial at ./vendor/google.golang.org/grpc/clientconn.go:106 11 0x00000000007de6ad in main.main 在 bt 7， 我们看到了函数 Build(), 查找它的实现发现是一个接口，\n// Builder creates a resolver that will be used to watch name resolution updates. type Builder interface { // Build creates a new resolver for the given target. // // gRPC dial calls Build synchronously, and fails if the returned error is // not nil. Build(target Target, cc ClientConn, opts BuildOptions) (Resolver, error) // Scheme returns the scheme supported by this resolver. // Scheme is defined at https://github.com/grpc/grpc/blob/master/doc/naming.md. Scheme() string } 按照注释的意思大概得知，向 gRPC 注册（解析器）服务发现时，实际上注册的是 Builder，一般在 Build 中会开启单独的 groutine，进行 List-watcher 逻辑。\nBuild() 参数中的 ClientConn，提供了 Builder 和 clientconn.go 中的 ClientConn 结构体 交互的纽带，可以调用 cc.UpdateState(resolver.State{Addresses: addrList}) 来向 ClientConn 即时发送服务器列表的更新。\n注意，这里有两个名叫 ClientConn 的东西，\n一个是 clientconn.go 中的 ClientConn 结构体，位于 package gprc 另一个是 resolver.go 中的 ClientConn interface, 位于 package resolver ClientConn interface 的实现在 resolver_conn_wrapper.go 中的 ccResolverWrapper。\n但是最终，调用了 clientconn.go 中的 ClientConn，这也就是为什么它们叫了一样的名字的原因吧。\n所以说白了 ccResolverWrapper 把 internal 的 resolver多包了一层，承担了与 clientconn.go 的桥梁。\n说完这些，那么就不难理解 bt 3 中 ccBalancerWrapper 的作用了。\n总结 看完上面这些，总结一下 grpc client 建立 TCP 链接的过程。\ngrpc client 提供了 Resolve 协议和 Load Balance 的功能，所以即便是一个最简单的 Dial() 函数，也要经历 Resolver 和 Balancer 的代码。\nresolver 和 balancer 的核心代码在 internal 目录里，而在 grpc 主目录下，都提供了 Wrapper 函数，resolver_conn_wrapper.go, balancer_conn_wrapper.go 和 pickfirst.go\n参考资料 https://zhuanlan.zhihu.com/p/100200985 https://pandaychen.github.io/2019/11/11/GRPC-RESOLVER-DEEP-ANALYSIS/ ","wordCount":"544","inLanguage":"en","image":"https://runzhen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2020-10-11T00:00:00Z","dateModified":"2020-10-11T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://runzhen.github.io/posts/grpc-client-tcp-connection/"},"publisher":{"@type":"Organization","name":"Mind in the Wind","logo":{"@type":"ImageObject","url":"https://runzhen.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://runzhen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://runzhen.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://runzhen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://runzhen.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://runzhen.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://runzhen.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">gRPC-go 建立 TCP 连接的过程</h1><div class=post-meta><span title='2020-10-11 00:00:00 +0000 UTC'>2020-10-11</span>&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li><li><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a></li></ul></div></details></div><div class=post-content><p>首先看一个最简单的建立 client server 之间 gRPC 连接的代码，以这个代码为例，分析一下 TCP 是在何时建立的。</p><p>Server 端的代码相对来说很容易，一个最简单的 server 代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>lis</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Listen</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;:%d&#34;</span><span class=p>,</span> <span class=mi>8080</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>grpcServer</span> <span class=o>:=</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>NewServer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>protobuf</span><span class=p>.</span><span class=nf>RegisterTestServer</span><span class=p>(</span><span class=nx>grpcServer</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>server</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	<span class=nx>grpcServer</span><span class=p>.</span><span class=nf>Serve</span><span class=p>(</span><span class=nx>lis</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在 grpc/server.go 中的 Serve() 函数调用了 <code>lis.Accept()</code> 并阻塞，当 client 端发来 TCP 请求时，Accept() 返回 Conn 结构，并开启 goroutine <code>handleRawConn()</code> 进行后续的处理。</p><p>就 TCP 来说，server 端的代码简单易懂，相比之下 client 端则不一样，一个基本的 Client 代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=s>&#34;localhost:8080&#34;</span><span class=p>,</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>WithInsecure</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>cli</span> <span class=o>:=</span> <span class=nx>protobuf</span><span class=p>.</span><span class=nf>NewTestClient</span><span class=p>(</span><span class=nx>conn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>而要弄清楚 Client 端如何建立 TCP 却不容易，这是因为 grpc client 有 resolve DNS 以及做 load balancer 的功能，因此代码复杂很多。</p><p>从上面的代码不难看出肯定是在 Dial() 函数中建立的，它的具体实现是在 <code>DialContext()</code>, 返回 <code>ClientConn</code> 结构体指针，但是却看不到在哪建立了 TCP 链接，这是因为 TCP 链接是在一个 Goroutine 中异步建立的。如果想要 <code>DialContext()</code> 等连接建立完再返回，可以指定grpc.WithBlock()传入Options来实现。</p><p>下面就来剖析一下整个过程。</p><p>先说结论，client 是在 <code>clientconn.go</code> 文件的 <code>connect()</code> 里面 <code>go ac.resetTransport()</code> 建立了到 server 的 TCP 链接的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=c1>// connect starts creating a transport.</span>
</span></span><span class=line><span class=cl><span class=c1>// It does nothing if the ac is not IDLE.</span>
</span></span><span class=line><span class=cl><span class=c1>// TODO(bar) Move this to the addrConn section.</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>ac</span> <span class=o>*</span><span class=nx>addrConn</span><span class=p>)</span> <span class=nf>connect</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ac</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>ac</span><span class=p>.</span><span class=nx>state</span> <span class=o>==</span> <span class=nx>connectivity</span><span class=p>.</span><span class=nx>Shutdown</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>ac</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>errConnClosing</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>ac</span><span class=p>.</span><span class=nx>state</span> <span class=o>!=</span> <span class=nx>connectivity</span><span class=p>.</span><span class=nx>Idle</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>ac</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Update connectivity state within the lock to prevent subsequent or</span>
</span></span><span class=line><span class=cl>	<span class=c1>// concurrent calls from resetting the transport more than once.</span>
</span></span><span class=line><span class=cl>	<span class=nx>ac</span><span class=p>.</span><span class=nf>updateConnectivityState</span><span class=p>(</span><span class=nx>connectivity</span><span class=p>.</span><span class=nx>Connecting</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>ac</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Start a goroutine connecting to the server asynchronously.</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nx>ac</span><span class=p>.</span><span class=nf>resetTransport</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>接着跟踪 <code>ac.resetTransport()</code>, 调用顺序如下：<code>tryAllAddrs()</code> > <code>createTransport()</code> > <code>NewClientTransport()</code> > <code>newHTTP2Client()</code>, 最终，看到 <code>dial(connectCtx, opts.Dialer, addr.Addr)</code></p><p>可以在 dial 函数出设置断点验证我们的猜测，当程序执行到断点后，可以通过 netstat 命令查看 tcp 链接。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># netstat</span>
</span></span><span class=line><span class=cl>tcp       <span class=m>15</span>      <span class=m>0</span> 127.0.0.1:40972         127.0.0.1:8080  ESTABLISHED 9903/.
</span></span></code></pre></div><p>并使用 backtrace 验证调用栈</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=m>0</span>  0x0000000000748c02 in google.golang.org/grpc/internal/transport.newHTTP2Client   
</span></span><span class=line><span class=cl>   at ./vendor/google.golang.org/grpc/internal/transport/http2_client.go:174                                            
</span></span><span class=line><span class=cl><span class=m>1</span>  0x00000000007c21c8 in google.golang.org/grpc/internal/transport.NewClientTransport                                   
</span></span><span class=line><span class=cl>   at ./vendor/google.golang.org/grpc/internal/transport/transport.go:581                                               
</span></span><span class=line><span class=cl><span class=m>2</span>  0x00000000007c21c8 in google.golang.org/grpc.<span class=o>(</span>*addrConn<span class=o>)</span>.createTransport                                             
</span></span><span class=line><span class=cl>   at ./vendor/google.golang.org/grpc/clientconn.go:1300                                                                
</span></span><span class=line><span class=cl><span class=m>3</span>  0x00000000007c18ca in google.golang.org/grpc.<span class=o>(</span>*addrConn<span class=o>)</span>.tryAllAddrs                                                 
</span></span><span class=line><span class=cl>   at ./vendor/google.golang.org/grpc/clientconn.go:1223                                                                
</span></span><span class=line><span class=cl><span class=m>4</span>  0x00000000007c0e9f in google.golang.org/grpc.<span class=o>(</span>*addrConn<span class=o>)</span>.resetTransport                                              
</span></span><span class=line><span class=cl>   at ./vendor/google.golang.org/grpc/clientconn.go:1133
</span></span></code></pre></div><p>那么是怎么一步一步从 Dial() 调用到位于 clientconn.go 中的 <code>connect()</code> 函数呢？</p><p>这要从 client 端的 resolve DNS 以及 load balancer 说起，先看一张 gRPC 客户端负载均衡的架构图</p><p><img loading=lazy src=/image/2020/grpc-client.png alt=grpc></p><p>不难看出，client 端挺复杂的，左边是 Resolver 解析器，它主要完成下面这几个功能：</p><ul><li>服务发现的实现</li><li>和注册中心（Etcd、CoreDNS、Consul 等）通信，实时获取服务器的列表（或者处理变更信息）</li><li>将上步获取的数据发送给 Balancer，以便更新 Connection Pool（内置 gRPC 长连接池）</li></ul><p>结合上面的图，我们再来看一下 backtrace，结果符合我们的预期，可以看到，代码先执行到 Resolver，然后到 Balancer。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl> <span class=m>0</span>  0x00000000007bf3d3 in google.golang.org/grpc.<span class=o>(</span>*addrConn<span class=o>)</span>.connect
</span></span><span class=line><span class=cl>    at ./vendor/google.golang.org/grpc/clientconn.go:799
</span></span><span class=line><span class=cl> <span class=m>1</span>  0x00000000007ba408 in google.golang.org/grpc.<span class=o>(</span>*acBalancerWrapper<span class=o>)</span>.Connect
</span></span><span class=line><span class=cl>    at ./vendor/google.golang.org/grpc/balancer_conn_wrappers.go:264
</span></span><span class=line><span class=cl> <span class=m>2</span>  0x00000000007c59d4 in google.golang.org/grpc.<span class=o>(</span>*pickfirstBalancer<span class=o>)</span>.UpdateClientConnState
</span></span><span class=line><span class=cl>    at ./vendor/google.golang.org/grpc/pickfirst.go:102
</span></span><span class=line><span class=cl> <span class=m>3</span>  0x00000000007b93ab in google.golang.org/grpc.<span class=o>(</span>*ccBalancerWrapper<span class=o>)</span>.updateClientConnState
</span></span><span class=line><span class=cl>    at ./vendor/google.golang.org/grpc/balancer_conn_wrappers.go:127
</span></span><span class=line><span class=cl> <span class=m>4</span>  0x00000000007bde7c in google.golang.org/grpc.<span class=o>(</span>*ClientConn<span class=o>)</span>.updateResolverState
</span></span><span class=line><span class=cl>    at ./vendor/google.golang.org/grpc/clientconn.go:653
</span></span><span class=line><span class=cl> <span class=m>5</span>  0x00000000007c8134 in google.golang.org/grpc.<span class=o>(</span>*ccResolverWrapper<span class=o>)</span>.UpdateState
</span></span><span class=line><span class=cl>    at ./vendor/google.golang.org/grpc/resolver_conn_wrapper.go:177
</span></span><span class=line><span class=cl> <span class=m>6</span>  0x000000000075efc2 in google.golang.org/grpc/internal/resolver/passthrough.<span class=o>(</span>*passthroughResolver<span class=o>)</span>.start
</span></span><span class=line><span class=cl>    at ./vendor/google.golang.org/grpc/internal/resolver/passthrough/passthrough.go:48
</span></span><span class=line><span class=cl> <span class=m>7</span>  0x000000000075efc2 in google.golang.org/grpc/internal/resolver/passthrough.<span class=o>(</span>*passthroughBuilder<span class=o>)</span>.Build
</span></span><span class=line><span class=cl>    at ./vendor/google.golang.org/grpc/internal/resolver/passthrough/passthrough.go:34
</span></span><span class=line><span class=cl> <span class=m>8</span>  0x00000000007c7a31 in google.golang.org/grpc.newCCResolverWrapper
</span></span><span class=line><span class=cl>    at ./vendor/google.golang.org/grpc/resolver_conn_wrapper.go:103
</span></span><span class=line><span class=cl> <span class=m>9</span>  0x00000000007bb506 in google.golang.org/grpc.DialContext
</span></span><span class=line><span class=cl>    at ./vendor/google.golang.org/grpc/clientconn.go:301
</span></span><span class=line><span class=cl><span class=m>10</span>  0x00000000007de6ad in google.golang.org/grpc.Dial
</span></span><span class=line><span class=cl>    at ./vendor/google.golang.org/grpc/clientconn.go:106
</span></span><span class=line><span class=cl><span class=m>11</span>  0x00000000007de6ad in main.main
</span></span></code></pre></div><p>在 bt 7， 我们看到了函数 Build(), 查找它的实现发现是一个接口，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=c1>// Builder creates a resolver that will be used to watch name resolution updates.</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Builder</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Build creates a new resolver for the given target.</span>
</span></span><span class=line><span class=cl>	<span class=c1>//</span>
</span></span><span class=line><span class=cl>	<span class=c1>// gRPC dial calls Build synchronously, and fails if the returned error is</span>
</span></span><span class=line><span class=cl>	<span class=c1>// not nil.</span>
</span></span><span class=line><span class=cl>	<span class=nf>Build</span><span class=p>(</span><span class=nx>target</span> <span class=nx>Target</span><span class=p>,</span> <span class=nx>cc</span> <span class=nx>ClientConn</span><span class=p>,</span> <span class=nx>opts</span> <span class=nx>BuildOptions</span><span class=p>)</span> <span class=p>(</span><span class=nx>Resolver</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Scheme returns the scheme supported by this resolver.</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Scheme is defined at https://github.com/grpc/grpc/blob/master/doc/naming.md.</span>
</span></span><span class=line><span class=cl>	<span class=nf>Scheme</span><span class=p>()</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>按照注释的意思大概得知，向 gRPC 注册（解析器）服务发现时，实际上注册的是 Builder，一般在 Build 中会开启单独的 groutine，进行 List-watcher 逻辑。</p><p>Build() 参数中的 ClientConn，提供了 Builder 和 <code>clientconn.go</code> 中的 <code>ClientConn 结构体</code> 交互的纽带，可以调用 <code>cc.UpdateState(resolver.State{Addresses: addrList})</code> 来向 ClientConn 即时发送服务器列表的更新。</p><p>注意，这里有两个名叫 <code>ClientConn</code> 的东西，</p><ul><li>一个是 <code>clientconn.go</code> 中的 <code>ClientConn 结构体</code>，位于 package gprc</li><li>另一个是 <code>resolver.go</code> 中的 <code>ClientConn interface</code>, 位于 package resolver</li></ul><p><code>ClientConn interface</code> 的实现在 <code>resolver_conn_wrapper.go</code> 中的 <code>ccResolverWrapper</code>。</p><p>但是最终，调用了 clientconn.go 中的 ClientConn，这也就是为什么它们叫了一样的名字的原因吧。</p><p>所以说白了 ccResolverWrapper 把 <code>internal 的 resolver</code>多包了一层，承担了与 clientconn.go 的桥梁。</p><p>说完这些，那么就不难理解 bt 3 中 <code>ccBalancerWrapper</code> 的作用了。</p><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p>看完上面这些，总结一下 grpc client 建立 TCP 链接的过程。</p><p>grpc client 提供了 Resolve 协议和 Load Balance 的功能，所以即便是一个最简单的 <code>Dial()</code> 函数，也要经历 Resolver 和 Balancer 的代码。</p><p>resolver 和 balancer 的核心代码在 internal 目录里，而在 grpc 主目录下，都提供了 Wrapper 函数，<code>resolver_conn_wrapper.go</code>, <code>balancer_conn_wrapper.go</code> 和 <code>pickfirst.go</code></p><h3 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h3><ul><li><a href=https://zhuanlan.zhihu.com/p/100200985>https://zhuanlan.zhihu.com/p/100200985</a></li><li><a href=https://pandaychen.github.io/2019/11/11/GRPC-RESOLVER-DEEP-ANALYSIS/>https://pandaychen.github.io/2019/11/11/GRPC-RESOLVER-DEEP-ANALYSIS/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://runzhen.github.io/tags/grpc/>Grpc</a></li><li><a href=https://runzhen.github.io/tags/golang/>Golang</a></li></ul><nav class=paginav><a class=prev href=https://runzhen.github.io/posts/goroutine-pool/><span class=title>« Prev</span><br><span>Goroutine Pool 实现高并发</span>
</a><a class=next href=https://runzhen.github.io/posts/spanner-paper-reading/><span class=title>Next »</span><br><span>Spanner Distributed Database 阅读</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share gRPC-go 建立 TCP 连接的过程 on x" href="https://x.com/intent/tweet/?text=gRPC-go%20%e5%bb%ba%e7%ab%8b%20TCP%20%e8%bf%9e%e6%8e%a5%e7%9a%84%e8%bf%87%e7%a8%8b&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2fgrpc-client-tcp-connection%2f&amp;hashtags=grpc%2cgolang"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share gRPC-go 建立 TCP 连接的过程 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2fgrpc-client-tcp-connection%2f&amp;title=gRPC-go%20%e5%bb%ba%e7%ab%8b%20TCP%20%e8%bf%9e%e6%8e%a5%e7%9a%84%e8%bf%87%e7%a8%8b&amp;summary=gRPC-go%20%e5%bb%ba%e7%ab%8b%20TCP%20%e8%bf%9e%e6%8e%a5%e7%9a%84%e8%bf%87%e7%a8%8b&amp;source=https%3a%2f%2frunzhen.github.io%2fposts%2fgrpc-client-tcp-connection%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share gRPC-go 建立 TCP 连接的过程 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frunzhen.github.io%2fposts%2fgrpc-client-tcp-connection%2f&title=gRPC-go%20%e5%bb%ba%e7%ab%8b%20TCP%20%e8%bf%9e%e6%8e%a5%e7%9a%84%e8%bf%87%e7%a8%8b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share gRPC-go 建立 TCP 连接的过程 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frunzhen.github.io%2fposts%2fgrpc-client-tcp-connection%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share gRPC-go 建立 TCP 连接的过程 on whatsapp" href="https://api.whatsapp.com/send?text=gRPC-go%20%e5%bb%ba%e7%ab%8b%20TCP%20%e8%bf%9e%e6%8e%a5%e7%9a%84%e8%bf%87%e7%a8%8b%20-%20https%3a%2f%2frunzhen.github.io%2fposts%2fgrpc-client-tcp-connection%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share gRPC-go 建立 TCP 连接的过程 on telegram" href="https://telegram.me/share/url?text=gRPC-go%20%e5%bb%ba%e7%ab%8b%20TCP%20%e8%bf%9e%e6%8e%a5%e7%9a%84%e8%bf%87%e7%a8%8b&amp;url=https%3a%2f%2frunzhen.github.io%2fposts%2fgrpc-client-tcp-connection%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share gRPC-go 建立 TCP 连接的过程 on ycombinator" href="https://news.ycombinator.com/submitlink?t=gRPC-go%20%e5%bb%ba%e7%ab%8b%20TCP%20%e8%bf%9e%e6%8e%a5%e7%9a%84%e8%bf%87%e7%a8%8b&u=https%3a%2f%2frunzhen.github.io%2fposts%2fgrpc-client-tcp-connection%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://runzhen.github.io/>Mind in the Wind</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>